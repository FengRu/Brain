# Chapter 12 {#chapter_12}

## 模块

### 模块和文件

一个文件被看作是一个独立的模块，一个模块也可以被看作是一个文件。模块的名字就是文件的名字去掉扩展名**.py**。与其它可以导入类的语言不同，在Python中导入的是模块或模块属性。

### 搜索路径和路径搜索

模块的导入需要一个"路径搜索"的过程。Python解释器会在文件系统的一个路径下搜索需要导入的模块。而这个目录是通过"搜索路径"来定义的。

默认搜索路径是在编译或是安装时指定的。它可以在两个地方修改：

* 保存在启动Python的shell或命令行的PYTHONPATH环境变量。
* 解释器启动之后，也可以访问这个搜索路径，它会被保存在sys模块的**sys.path**变量里。
  该变量中存放的是搜索路径列表，如果知道需要导入的模块是什么，而它的路径不在搜索路径里，那么只需要调用列表的**append()**方法即可。

如果存在多个版本的同名的模块，则Python会按照搜索路径查找模块，并且导入搜索到的第一个模块。

使用**sys.modules**可以找到当前导入了哪些模块和它们来自什么地方。和**sys.path**不同**，sys.modules**是一个字典，使用模块名作为键（key），对应路径作为值（value）。

## 名字空间

名称空间是名称(标识符)到对象的映射。向名称空间添加名称的操作过程涉及到绑定标识符到指定对象的操作(以及给该对象的引用计数加1)。

Python解释器首先加载内建名称空间。它由\_\_builtins\_\_模块中的名字构成。随后加载执行模块的全局名称空间，它会在模块开始执行后变为活动名称空间。这时创建了两个活动的名字空间，即内建名字空间和全局名字空间。


### \_\_builtins\_\_和\_\_builtin\_\_

\_\_builtins\_\_模块包含内建名称空间中内建名字的集合。其中大多数(如果不是全部的话)来自\_\_builtin\_\_模块，该模块包含内建函数，异常以及其他属性。在标准Python执行环境下，\_\_builtins\_\_引用包含\_\_builtin\_\_的所有名字。


#### \_\_builtin\_\_，\_\_builtins\_\_ 和 builtins的关系

在Python中，有一个内建模块，该模块在Python启动以后自动加载。该模块中的名字存在于内建名字空间中。

在Python 2.x中，内建模块被命名为**\_\_builtin\_\_**，但是在Python 3.x中，被更名为**builtins**。

而对于**\_\_builtins\_\_**，其实是对内建模块**\_\_builtin\_\_**（在Python 2.x下）或**builtins**（在Python 3.x下）的引用。

* **\_\_builtins\_\_**是对内建模块的引用，它和内建模块有一个共同点：
   Python程序启动的时候，它们都会在开始执行程序前被加载。
* 虽然是对内建模块的引用，但是还是有一些区别：
    * 在任何地方需要使用内建模块，都需要在该作用域内导入内建模块，
但是对于**\_\_builtins\_\_**却不需要导入，它在任何位置都可见（其实该引用对应的就是内建名字空间）。而内建模块名需要在相应的作用域内被import后才可见（这并不是把内建模块导入进来，内建模块在Python解释器启动以后就被加载了，这里的import只是将内建模块中的名字导入到内建名字空间中。）
    * 虽然**\_\_builtins\_\_**是对内建模块的引用，但是在不同的模块中使用，也存在区别：
	* 如果是在**\_\_main\_\_**模块中引用，**\_\_builtins\_\_**是对内建模块的完全引用，两者等价，这个时候，**\_\_builtins\_\_**是模块类型
	* 如果是在非**\_\_main\_\_**模块中引用，**\_\_builtins\_\_**仅仅是对**\_\_builtin\_\_.\_\_dict\_\_**的引用，这个时候，**\_\_builtins\_\_**的类型是字典类型。

如果在执行期间调用了一个函数，那么将创建出第三个名称空间，即局部名称空间。可以通过**globals()**和**locals()**内建函数判断出某一名字属于哪个名称空间。

### 名称空间与变量作用域

名称空间是纯粹意义上的名字和对象间的映射关系，而作用域还指出了从用户代码的哪些物理位置可以访问到这些名字。

注意：

每个名称空间是一个自我包含的单元。但从作用域的观点来看，事情是不同的。所有局部名称空间的名称都在局部作用范围内。局部作用范围以外的所有名称都在全局作用范围内。
在程序执行过程中， 局部名称空间和作用域会随函数调用而不断变化， 而全局名称空间是不变的。

#### 名称查找，确定作用域，覆盖

确定作用域的规则是通过名称查询联系到名称空间的，访问一个属性时，解释器必须在三个名称空间中的一个找到它。首先从局部名称空间开始，如果没有找到，解释器将继续查找全局名称空间.如果这也失败了，它将在内建名称空间里查找。
当在优先查询的作用域中找到了名字，则如果在外围名字空间中存在同名的名字，则外围的名字空间中的名字被覆盖。

#### 无限制的名称空间

Python的一个有用的特性在于可以在任何需要放置数据的地方获得一个名称空间。如：可以在任何时候给一个函数添加属性，通过**function.attribute**添加，这时获得了函数function的名字空间，attribute属性只在function的名字空间中。

## 导入模块 

import语句语法：

~~~

import module1[， module2[，... moduleN]]

~~~

模块导入过程遵循作用域原则，如果在一个模块的顶层导入，那么它的作用域就是全局的;如果在函数中导入，那么它的作用域是局部的。

### from-import语句

可以在当前作用域中导入指定的模块属性，也就是把指定名称导入到当前作用域。使用from-import语句可以实现这种目的，它的语法是:

~~~

from module import name1[， name2[，... nameN]]

~~~

### 多行导入

多行导入特性是Python2.4为较长的from-import提供的。

使用多行的from-import语句，将一行from-import语句划分为多行:

~~~

from moudle import name1, name2, ...
form module import namen, namem, ...

#详见：PEP 328

~~~

### 扩展的import语句(as)

使用扩展的import，就可以在导入的同时为模块或属性指定别名。通过as关键字实现：

~~~

import modulename as perfername

from modulename import atrributename as prefername

~~~

### 模块导入的特性

#### 载入时执行模块

加载模块会导致这个模块被"执行"。也就是被导入模块的顶层代码将直接被执行。这通常包括设定全局变量以及类和函数的声明。如果有检查**\_\_name\_\_**的操作，那么它也会被执行。

#### 导入(import)和加载(load)

一个模块只被加载一次， 无论它被导入多少次。加载只在第一次导入时发生。

##### 导入到当前名称空间的名称

调用**from-import**可以把名字导入当前的名称空间里去，这意味着不需要使用句点属性标识(.)来访问模块的标识符。也可以把指定模块的所有名称导入到当前名称空间里:

~~~

from module import *

~~~

##### 被导入到作用域的名字

只从模块导入名字的另一个副作用是那些名字会成为局部名称空间的一部分。这可能导致覆盖一个已经存在的具有相同名字的对象。

#### 关于__future__

**\_\_furure\_\_**指令实现了在Python中引入新特性的的方式。

使用**from-import**语句"导入"新特性，用户可以尝试一下新特性或特性变化，以便在特性固定下来的时候修改程序。它的语法是:

~~~

from __future__ import new_feature 

~~~

不能使用如下方式导入，必须显式得导入指定的特性。

~~~

import __future__

~~~

### 从ZIP文件中导入模块

在2.3版中，Python加入了从ZIP归档文件导入模块的功能。如果搜索路径中存在一个包含Python模块(.py，.pyc，.pyo文件)的.zip文件，导入时会把ZIP文件当作目录处理，在文件中搜索模块。

如果要导入的一个ZIP文件只包含.py文件，那么Python不会为其添加对应的.pyc文件，这意味着如果一个ZIP归档没有匹配的.pyc文件时，导入速度会相对慢一点。

### "新的"导入钩子

这之前实现自定义导入器只能是使用一些很古老的模块，它们并不会简化创建导入器。另一个解决方法是覆盖\_\_import\_\_()，但这并不简单，你需要(重新)实现整个导入机制。Python2.3引入的新导入钩子，从而简化了这个操作。只需要编写可调用的import类，然后通过sys模块"注册"(或者叫"安装")它。

实现自定义导入需要两个类，一个查找器和一个载入器。这些类的实例接受一个参数：模块或包的全名称。查找器实例负责查找你的模块，如果它找到，那么它将返回一个载入器对象。查找器可以接受一个路径用以查找子包(subpackages)。载入器会把模块载入到内存。它负责完成创建一个Python模块所需要的一切操作，然后返回模块。


这些实例被加入到**sys.path_hooks**。**sys.path_importer_cache**只是用来保存这些实例，这样就只需要访问**path_hooks**一次。最后，**sys.meta_path**用来保存一系列需要在查询**sys.path**之前访问的实例，这些是为那些已经知道位置而不需要查找的模块准备的。**meta-path**已经有了指定模块或包的载入器对象的读取器。

### 模块内建函数

#### \_\_import\_\_()函数

Python1.5加入了\_\_import\_\_()函数，它作为实际上导入模块的函数，这意味着import语句调用\_\_import\_\_()函数完成它的工作。提供这个函数是为了让有特殊需要的用户覆盖它，实现自定义的导入算法。

\_\_import\_\_()函数用法:  

~~~

__import__(module_name[， globals[， locals[， fromlist]]]) 

~~~

 *module_name* 变量是要导入模块的名称， *globals* 是包含当前全局符号表的名字的字典， *locals* 是包含局部符号表的名字的字典， *fromlist* 是一个使用from-import语句所导入符号的列表。 *globals* ， *locals* ，以及 *fromlist* 参数都是可选的，默认分别为 *globals()* ， *locals()* 和 *[]* 。

### globals()和locals()

**globals()**和**locals()**内建函数分别返回调用者全局和局部名称空间的字典。在一个函数内部，局部名称空间代表在函数执行时候定义的所有名字，**locals()**函数返回的就是包含这些名字的字典。**globals()**会返回函数可访问的全局名字。在全局名称空间下，**globals()**和**locals()**返回相同的字典，因为这时的局部名称空间就是全局空间。

### reload()

**reload()**内建函数可以重新导入一个已经导入的模块。

~~~

reload(module)

~~~

 *module* 是想要重新导入的模块。使用**reload()**的时候有一些要求：

* 首先模块必须是全部导入(不是使用**from-import**)
* 它必须被成功导入
* 另外**reload()**函数的参数必须是模块对象而不是表示模块名字的字符串。
  也就是说必须类似reload(sys)而不是reload('sys')。

模块中的代码在导入时被执行，但只执行一次.以后执行import语句不会再次执行这些代码，只是绑定模块名称。而**reload()**函数不同，它会重新执行一次。

## 包

包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的Python应用程序执行环境。Python1.5加入了包，用来帮助解决如下问题:

* 为平坦的名称空间加入有层次的组织结构 
* 允许程序员把有联系的模块组合到一起 
* 允许分发者使用目录结构而不是一大堆混乱的文件 
* 帮助解决有冲突的模块名称 
 
与类和模块相同，包也使用句点属性标识来访问他们的元素。使用标准的**import**和**from-import**语句导入包中的模块。

### 目录结构

#### 使用**import-from**方式导入包：

1. 只导入顶层的子包， 然后使用成员操作符向下引用子包树: 

    ~~~

    from Phone import Mobile 
    Mobile.Analog.dial()

    ~~~

2. 引入子包: 

    ~~~

    from Phone.Mobile import Analog 
    Analog.dial()

    ~~~

3. 一直沿子包的树状结构导入: 

    ~~~

    from Phone.Mobile.Analog import dial  
    dial()

    ~~~

目录结构中，存在很多的\_\_init\_\_.py文件。这些是初始化模块，**from-import**语句导入子包时需要用到它。如果没有用到，他们可以是空文件。程序员经常忘记为它们的包目录加入\_\_init\_\_.py文件，从Python2.5开始，这将会导致一个**ImportWarning**信息。

除非给解释器传递了-Wd选项，否则警告会被简单地忽略。

### 使用from-import导入包

包同样支持from-import all语句

~~~

from package.module import * 

~~~

然而，这样的语句会导入哪些文件取决于操作系统的文件系统.所以在\_\_init\_\_.py中加入\_\_all\_\_变量.该变量包含执行这样的语句时应该导入的模块的名字.它由一个模块名字符串列表组成。

### 绝对导入

包的使用越来越广泛，很多情况下导入子包会导致和真正的标准库模块发生冲突。包模块会把名字相同的标准库模块隐藏掉，因为它首先在包内执行相对导入，隐藏掉标准库模块。为此，所有的导入现在都被认为是绝对的，也就是说这些名字必须通过Python路径**sys.path**或是**PYTHONPATH**来访问。

从Python2.7开始，绝对导入特性将成为默认功能。

### 相对导入

因为**import**语句总是绝对导入的，所以相对导入只应用于**from-import**语句。语法的第一部分是一个句点，指示一个相对的导入操作。之后的其他附加句点代表当前from起始查找位置后的一个级别。

从2.5版开始，相对导入被加入到了Python中。在Python2.6中，在模块内部的导入如果没有使用相对导入，那么会显示一个警告信息。

### 模块的其他特性

#### 自动载入的模块

当Python解释器在标准模式下启动时，一些模块会被解释器自动导入，用于系统相关操作。**sys.modules**变量包含一个由当前载入(完整且成功导入)到解释器的模块组成的字典，模块名作为键，它们的位置作为值。

#### 不区分大小的导入

必须指定**PYTHONCASEOK**的环境变量，这样Python会导入第一个匹配模块名(使用不区分大小写的习惯)。否则Python会执行它的原生区分大小写的模块名称匹配，导入第一个匹配的模块。

## 源代码编码

从Python2.3开始，Python的模块文件开始支持除7位ASCII之外的其他编码。ASCII是默认的，只要在Python模块头部加入一个额外的编码指示说明就可以让导入者使用指定的编码解析模块，编码对应的Unicode字符串。
一个 UTF-8 编码的文件可以这样指示: 

~~~

# -*- coding: UTF-8 -*-

~~~

如果执行或导入了包含非ASCII的Unicode字符串而没有在文件头部说明，那么会在Python2.3得到一个**DeprecationWarning**，而在2.5中这样做会导致语法错误。

## 相关模块

imp
:   这个模块提供了一些底层的导入者功能。

modulefinder
:   该模块允许你查找Python脚本所使用的所有模块。
    你可以使用其中的ModuleFinder类或是把它作为一个脚本执行，
    提供你要分析的(另个)Python模块的文件名。

pkgutil
:   该模块提供了多种把Python包打包为一个"包"文件分发的方法。
    类似site模块，它使用\*.pkg文件帮助定义包的路径，
    类似site模块使用的\*.pth文件。

site
:   和\*.pth文件配合使用，指定包加入Python路径的顺序，
    例如sys.path，PYTHONPATH。你不需要显式地导入它，
    因为Python导入时默认已经使用该模块。
    你可能需要使用-S开关在Python启动时关闭它。
    你也可以完成一些site相关的自定义操作，例如在路径导入完成后在另个地方尝试。

zipimport
:   你可以使用该模块导入ZIP归档文件中的模块。
    需要注意的是该功能已经"自动"开启，所以你不需要在任何应用中使用它。

distutils
:   该模块提供了对建立、安装、分发Python模块和包的支持。
    它还可以帮助建立使用C/C++完成的Python扩展。
