# Chapter 6 {#chapter_6}

## 序列

序列类型有着相同的访问模式：每一个元素可以通过指定一个偏移量的方式得到，而多个元素可以通过切片操作方式一次得到。

下标偏移量：

* 如果是正数偏移量是从0开始到n-1。
* 如果是负数偏移量，则是从-n开始到-1。

### 标准类型操作符

标准类型操作符一般都能使用于所有的序列类型，但是不一定适用复合类型的对象。

### 序列类型操作符

如下的序列类型操作符优先级从高到低：

成员关系操作符（in ，not in）：

~~~

 >>> 1 in [1, 2]
 True

~~~

成员关系操作符使用来判断一个元素是否属于一个序列。**in/not in**操作符返回值一般为True和False。

连接操作符（+）：

这个操作符允许把一个序列和另一个相同类型的序列做连接，sequence_1 + sequence_2 这个表达式的结果是一个包含sequence_1和sequence_2的内容的新序列。

~~~

 >>> [1, 2, 3] + [4, 5, 6]
 [1, 2, 3, 4, 5, 6]

~~~

注意：这种方式的操作不是最快和最有效的。对于字符串来说，这种操作不如把所有的子字符串放到一个列表或可迭代对象中，然后调用一个join方法把所有的内容连接起来，这样更节约内存。对于列表，使用extend()方法把两个子字符串合并要更加高效，但是这种方法的返回值是None。

重复操作符（\*）：

当需要将一个序列进行多份拷贝的时候，重复操作符很有用。       

~~~

 >>> [1, 2] * 2
 [1, 2, 1, 2]

~~~

该操作符返回一个包含多份原对象拷贝的新对象。

切片操作符(\[start : end : step\])：

切片操作:允许通过指定下标的方式来获得某一个数据元素，或者通过指定下标范围来获得一组序列的元素。

~~~

 >>> l = [1, 2, 3, 4]
 >>> l[0]
 1
 
 >>> l[1:2]
 [2]
 
 >>> l[0:4:2]
 [1, 3]
 
~~~

切片索引比简单的单一元素索引来的灵活，开始和结束索引值可以超过字符串的长度。


### 内建函数

#### 类型转换

内建函数**list()**，**str()**，**tuple()**被用来在各个序列类型之间进行转换。这些转换函数是工厂函数，将对象作为参数，并将内容浅拷贝(浅拷贝指只是拷贝了对象的引用，而不是建立一个对象)到新生成的对象中。

序列类型转换工厂函数：

**list(iter)**
:   把可迭代对象转换为列表

**str(obj)**	
:   把obj对象转换为字符串(对象的字符串表示)

**unicode(obj)**
:   把对象转换成unicode字符串(使用默认编码)

**basestring()**
:   抽象工厂函数，为str和unicode函数提供父类，所以不能被实例化，也不能被调用。

**tuple(iter)**	
:   把一个可迭代对象转换为一个元组对象


~~~

 >>> list("hello")
 ['h', 'e', 'l', 'l', 'o']

 >>> tuple("hello")
 ('h', 'e', 'l', 'l', 'o')

 >>> list(('h', 'e', 'l', 'l', 'o'))
 ['h', 'e', 'l', 'l', 'o']

 >>> tuple(['h', 'e', 'l', 'l', 'o'])
 ('h', 'e', 'l', 'l', 'o')

 >>> str([1, 2, 3])
 '[1, 2, 3]'

 >>> str((1, 2, 3))
 '(1, 2, 3)'

~~~

Python为序列提供了可操作的内建函数：

**enumerate(iter)**	
:   接受一个可迭代对象iter作为参数，返回一个enumerate对象(同时也是一个迭代器)，该对象生成每个元素的index值和item值组成的元组。

**len(seq)**
:   返回序列的长度

**max(iter, key = None)/max(arg1, arg2, arg3...,key = None)**
:   返回可迭代对象iter或(arg1, arg2, ....)中的最大值，如果指定了key，这个key必须是一个可以传给sort()函数的，用于比较的回调函数。

**min(iter, key - None)/min(arg1, arg2, arg3...,key = None)**	
:   返回iter里面的最小值，或者返回(arg1, arg2, ....)里的最小值，如果指定了key，这个key必须是一个可以传递给sort()方法的，用于比较的回调函数。

**reversed(seq)**	
:   接受一个序列作为参数，返回一个以逆序访问的迭代器

**sorted(iter, func = None, key = None, reverse = False)**
:   接受一个可迭代对象作为参数，返回一个有序的列表，可选参数func，key和reverse的含义跟list.sort()内建函数的参数含义一样

**sum(seq, init = 0)**	
:   返回seq和可选参数init的总和

**zip([it0, it1, it2....itN])**
    :		它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。


注意：
**enumerate()**,**sum()**是Python2.3增加的
**max()**和**min()**是从Python2.5开始支持key参数
**reversed()**,**sorted()**,是从Python2.4开始支持
**zip()**从Python2.0开始加入，在Python2.4中增强
**len()** ,**reversed()**,**sum()** 函数只能接受序列类型的对象作为参数，而剩下的则可以接受可迭代对象作为参数。另外，max()和min()函数也可以接受一个参数列表。

~~~

 #enumerate
 >>> for item in enumerate("hello"):
	print item
	
 (0, 'h')
 (1, 'e')
 (2, 'l')
 (3, 'l')
 (4, 'o')

 #zip
 >>> zip([1, 2, 3], [1, 2, 3])
 [(1, 1), (2, 2), (3, 3)]

 >>> zip([1, 2, 3], [1, 2, 3], [1, 3, 3])
 [(1, 1, 1), (2, 2, 3), (3, 3, 3)]

 >>> zip([1, 2], [1, 2, 3])
 [(1, 1), (2, 2)]

~~~

## 字符串

Python中存在3种类型的字符串，包括：

* 通常意义上的字符串
* Unicode字符串
* basestring抽象类
    
前两个是后者的子类，basestring不能被实例化。

### 字符串和操作符

#### 切片操作

切片操作的索引值：

~~~

  0  1  2  3  4
  h  e  l  l  o
 -5 -4 -3 -2 -1

~~~

~~~

 >>> s = "hello"
 >>> s[-2: -1]
 'l'

 >>> s[-len(s):]
 'hello'

 >>> s[1: 3]
 'el'

 >>> s[len(s)-1::-1]
'olleh'

 >>> s[-3:-1]
 'll'

 >>> s[-1:-3:-1]
 'ol'

~~~

#### 成员操作符(in, not in)

成员操作符用于判断一个字符或者一个子串是否在另一个字符串中。注意，成员操作符不是用来判断一个字符串是否包含了另外一个字符串的，这样的功能可以用**find()(rfind())**和**index()(rindex())**提供。

~~~

 >>> s = 'hello'
 >>> 'he' in s
 True

~~~

string模块预定义字符串：

~~~

 >>> import string
 >>> string.ascii_uppercase  
 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

 >>> string.ascii_lowercase 
 'abcdefghijklmnopqrstuvwxyz' 

 >>> string.ascii_letters 
 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' 

 >>> string.digits 
 '0123456789'

~~~

#### 编译时字符串连接

除了使用加法(+)将两个字符串在运行时连接起来，Python中还有一种在编译时连接两个字符串，把两个字符串在编译时连接成一个字符串。

~~~

 >>> 'hello' ' world'
 'hello world'

~~~

通过这种方法，你可以把长的字符串分成几部分来写，而不用加反斜杠，你可以在一行里面混用两种分号，这种写法的好处是你可以把注释也加进来，如下: 

~~~

 >>> f = urllib.urlopen('http://' # protocol 
 ... 'localhost' # hostname 
 ... ':8000' # port 
 ... '/cgi-bin/friends2.py')  # file 

~~~

等价于下面的方式: 

~~~

 >>> 'http://' 'localhost' ':8000' '/cgi-bin/friends2.py' 
 'http://localhost:8000/cgi-bin/friends2.py'

~~~

#### 普通字符串转换为Unicode字符串

如果把一个普通字符串和一个Unicode字符串连接起来处理，则在连接前将普通字符串转换为Unicode类型的字符串。

#### 重复操作符(\*)

重复操作符创建一个包含了原有字符串的多个拷贝的新串。

~~~

 >>> 'h' * 2
 'hh'

~~~

### 只适用于字符串的操作符

格式化操作符(%)

Python风格的字符串格式化操作符，适用于字符串类型，非常类似于C语言中的printf()函数的字符串格式化。

Python字符串格式化符号：

|      |								|
|:-----|:---------------------------------------------------------------|
|%c    |转换为字符(ASCII码值，或者长度为一的字符串)			|
|%r    |优先用repr()函数进行字符串转换(在Python2.0中新增)		|
|%s    |优先用str()函数进行字符串转换					|
|%d/%i |转换成有符号的十进制数						|
|%u    |转换成无符号的十进制数						|
|%o    |转换成无符号八进制数						|
|%x/%X |转换成无符号十六进制数(x表示转换后为小写，X表示转换后为大写)	|
|%e/%E |转换成科学记数法						|
|%f/%F |转换成浮点数(小数部分自然截断)					|
|%g/%G |%e和%f/%E和%F的简写						|
|%%    |输出%								|

在Python2.4中，%u/%o/%x/%X在遇到负数的时候会返回一个有符号字符串。

~~~

 >>> '%s %s' % 'hello' 'world'
 'hello world'

 >>> '%u' % -1
 '-1'

 >>> '%o' % -1
 '-1'

 >>> '%x' % -10
 '-a'

 >>> '%X' % -10
 '-A'
~~~

Python支持两种格式的输入参数，第一种是元组，另一种是字典形式。

~~~

 >>> '%s %d' % ('Jack', 24)
 'jack 24'

 >>> '%(name)s %(age)d' % {'name': 'jack', 'age': 24}
 'jack 24'

~~~

格式化操作符辅助指令，用在%后面

|	   |								  |
|:---------|:-------------------------------------------------------------|
| *	   |定义宽度或者小数点精度					  |
| -	   |用作左对齐							  |
| +	   |在正数前面显示加号						  |
|空格	   |在正数前显示空格						  |
|#	   |在八进制数前显示0，在十六进制前显示'0x'或者'0X'		  |
|0	   |显示的数字前面填充0，而不是空格				  |
|(var)     |映射变量(字典参数)						  |
|m.n       |m是显示的最小总宽度，n是小数点后的位数(如果可用，自动进位).	  |

### 原始字符串操作符(r/R)

原始字符串的目的是为了处理在字符串中包含特殊字符的情况，在原始字符串中，所有的字符都会直接按照字符的字面意思使用，不会转义。

原始字符串是在字符串的前面添加一个r/R将该字符串转化为原始字符串。

~~~

 >>> r'hello'
 'hello'

 >>> R'hello'
 'hello'

~~~

### Unicode字符串操作符(U/u)

Unicode字符串操作符由U或u表示，用于将标准字符串或者是包含Unicode字符的字符串转换为完全的Unicode字符串。

在标准字符串前添加u或U将其转换为Unicode字符串。

~~~

 >>> u'hello'
 u'hello'

 >>> U'hello'
 u'hello'

~~~

### 内建函数

**raw_input(prompt)**
:   raw_input内建函数用给定字符串prompt提示用户输入并将输入内容以字符串的形式返回(在Python3中将raw_input重命名为input，不再支持raw_input)


### 字符串的独特特性

#### 特殊字符串和控制字符

像其他高级语言和脚本语言一样，一个反斜线加一个单一字符可以表示一个特殊字符,通常用于表示一个不可打印的字符，这就是特殊字符，如果这些特殊字符是包含在一个原始字符串中的，那么它就失去了转义的功能.

~~~

 >>> print "hello\nworld"
 hello
 world

 >>> print r"hello\nworld"
 hello\nworld

~~~

除了通常用的特殊字符，比如换行符(\n),tab 符(\t)之外，也可以直接用 ASCII 码值来标示特殊字符:\000 或者\x00，分别对应字符的八进制和十六进制 ASCII 码值。

~~~

 >>> print '\141'
 a
 
 >>> print '\x61'
 a

~~~

跟C字符串的不同之处是Python的字符串并不是以NUL(\000)作为结束符的，NUL跟其他的反斜杠转义字符一样，可以出现在字符串的任意位置，可以包含任意个数。

控制字符的一个作用是用做字符串里面的定界符，在数据库或者web应用中，大多数的可打印字符都是被允许用在数据项里面的，就是说可打印的字符不适合做定界符.用可打印的字符串比如冒号(:)来作定界符，将会很难分辨一个字符到底是数据还是定,界符.而且还会限定你能用在数据项里面的字符数量，而这不是你想要的.一个通常的解决方案是，使用那些不经常使用的，不可打印的,ASCII,码值来作为定界符,它们是非常完美的定界符,这样一来诸如冒号这样的可打印字符就可以解脱出来用在数据项中了.

#### 三引号

虽然可以用单引号或者双引号来定义字符串，但是如果需要包含诸如换行符这样的特殊字符时，单引号或者双引号就不是那么方便了。Python的三引号就是为了解决这个问题的，它允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符.

#### 字符串不变性

对像字符串这样的不可变对象,左值必须是一个完整的对象，比如说一个字符串对象，不能是字符串的一部分.对赋值操作的右值没有这个限制.

### Unicode

从 Python1.6 起引进的 Unicode 字符串支持,是用来在多种双字节字符的格式、编码进行转换的,其中包括一些对这类字符串的操作管理功能。内建的字符串和正则表达式对 Unicode 字符串提供了支持

内建的**str()**函数和**chr()**函数并没有升级成可以处理Unicode字符.它们只能处理常规的ASCII编码字符串,如果一个 Unicode 字符串被作作为参数传给了 str()函数，它会首先被转换成 ASCII 字符串然后在交给 str()函数.如果该 Unicode 字符串中包含任何不被 ASCII 字符串支持的字符，会导致 str()函数报异常.同样地,chr()函数只能以 0 到 255 作为参数工作.如果你传给它一个超出此范围的值(比如说一个 Unicode 字符),它会报异常. 

新的内建函数 **unicode()**和 **unichar()**可以看成 Unicode 版本的 str()和chr(). **unicode()** 函数可以把任何 Python 的数据类型转换成一个 Unicode字符串,如果是对象，并且该对象定义了**\_\_unicode\_\_()**方法，它还可以把该对象转换成相应的 Unicode 字符串

### 编码

Unicode 支持多种编码格式，每当向一个文件写入字符串的时候，必须定义一个编码(encoding 参数)用于把对应的 Unicode 内容转换成你定义的格式,Python 通过 Unicode 字符串的 encode()函数解决了这个问题。

不到必须时不要在程序里面编解码 Unicod 字符.只在写入文件或数据库或者网络时，才调用 encode()函数;相应地，只在需要把数据读回来的时候才调用 decode()函数.

#### Unicode在程序中的应用

Python 标准库里面的绝大部分模块都是兼容 Unicode 的.除了 pickle 模块！pickle 模块只支持 ASCII 字符串。如果你把一个 Unicode 字符串交给 pickle 模块来 unpickle,它会报异常.

#### Python的Unicode支持

内建函数：
**decode()**、**encode()**内建函数接受一个字符串做参数返回该字符串对应的解码后/编码后的字符串.**decode()**和**encode()**都可以应用于常规字符串和 Unicode字符串.**decode()**方法是在Python2.2以后加入的.

#### 字符串格式化操作符

对于Python的格式化字符串的操作符,%s把Python字符串中的Unicode对象执行了str(u)操作,所以，输出的应该是u.encode(默认编码).如果格式化字符串是Unicode对象,所有的参数都将首先强制转换成Unicode然后根据对应的格式串一起进行格式转换.数字首先被转换成普通字符串，然后在转换成Unicode.Python字符串通过默认编码格式转化成Unicode.Unicode对象不变，所有其他格式字符串都需要像上面这样转化

## 相关模块

Python标准库里面与字符串有关的主要模块：

string		
:   字符串操作相关函数和工具，比如Template类.

re
:   正则表达式:强大的字符串模式匹配模块

struct		
:   字符串和二进制之间的转换

c/StringIO	
:   字符串缓冲对象，操作方法类似于file对象.

base64		
:   Base16,32,64数据编解码

codecs		
:   解码器注册和基类

crypt		
:   进行单向加密

difflib		
:   找出序列间的不同\[a\]

hashlib		
:   多种不同安全哈希算法和信息摘要算法的API\[b\]

hma
:   HMAC信息鉴权算法的Python实现\[c\]

md5
:   RSA的MD5信息摘要鉴权\[d\]

rotor		
:   提供多平台的加解密服务

sha
:   NIAT的安全哈希算法SHA[d]

stringprep
:   提供用于IP协议的Unicode字符串\[e\]

textwrap	
:   文本打包和填充\[e\]

unicodedata	
:   Unicode数据库\[e\]

[a]Python2.1新加	
[b]Python2.5新加	
[c]Python2.2新加	
[d]Python2.5的hashlib中废除	
[e]Python2.3新加	

### re模块
Python1.5 中加入的 re 模块代替了早期的 regex 和 regsub 模块,全面采用了 Perl 正则表达式语法,使得 Python 在对正则表达式的支持方面前进了一大步. Python1.6 里面重写了正则表达式引擎(SRE),增加了对 Unicode 字符串的支持并对性能进行了重大的升级.SRE 引擎取代了原有正则表达式的模块下的 PCRE 引擎

## 列表

列表是能保留任意数目的Python对象的灵活的容器。列表不仅可以包含Python的标准类型,而且可以用用户定义的对象作为自己的元素.列表可以包含不同类型的对象,而且要比C或者Python自己的数组类型(包含在array扩展包中)都要灵活.

### 创建列表

~~~

List = []		#创建一个空列表
List = list(obj)	#通过list工厂函数创建一个列表

~~~

### 删除列表中的元素

要删除列表中的元素,如果你确切的知道要删除元素的素引可以用del语句,否则可以用**remove()**方法.通过**pop()**方法来删除并从列表中返回一个特定对象，一般是最后一个对象。

### 操作符

适用于序列的操作符都适用于列表。

从 Python1.5.2 起,我们可以用 **extend()**方法来代替连接操作符把一个列表的内容添加到另一个中去.使用 **extend()**方法比连接操作的一个优点是它实际上是把新列表添加到了原有的列表里面,而不是像连接操作那样新建一个列表。**extend()**成员方法也被用来做复合赋值运算,也就是 Python2.0 中添加的替换连接操作(+=).

### 内建函数

cmp()函数遵循如下的比较规则：

* 对两个列表的元素进行比较.
* 如果比较的元素是同类型的,则比较其值,返回结果.
* 如果两个元素不是同一种类型,则检查它们是否是数字.
    * 如果是数字,执行必要的数字强制类型转换,然后比较.
    * 如果有一方的元素是数字,则另一方的元素"大"(数字是"最小的")
    * 否则,通过类型名字的字母顺序进行比较.
* 如果有一个列表首先到达末尾,则另一个长一点的列表"大".
* 如果我们用尽了两个列表的元素而且所有元素都是相等的,那么结果就是个平局,返回一个0.

**len()** 
:   返回容器中元素的个数

**sum()**
:   对列表中的所有元素求和

**list() / tuple()**
:   list()函数和tuple()函数接受可迭代对象(比如另一个序列)作为参数,并通过**浅拷贝**来创建一个新的列表或者元组

list 和 tuple 的浅拷贝：

~~~

 >>> l = [1, [2], 3]
 >>> t = tuple(l)
 >>> t
 (1, [2], 3)

 >>> l[1][0] = 3
 >>> l
 [1, [3], 3]

 >>> t
 (1, [3], 3)

~~~

## 元组

元组是一种不可变类型。

### 元组的特殊特性

虽然元组是被定义成不可变的，但这并不影响它的灵活性。连接操作没有改变那些小元组。而是把它们的元素结合在一起。改变了原来元组的大小。这个也同样使用于重复操作符(\*)

~~~

 >>> (1, 2) + (3, 4)
 (1, 2, 3, 4)

 >>> (1, 2) * 3
 (1, 2, 1, 2, 1, 2)

~~~

虽然元组对象本身是不可变的，但这并不意味着元组包含的可变对象也不可变了。在元组中的元素如果是可变的，那么可以修改元素对象中的值，比如元组中的列表对象。

### 默认集合类型

* 所有的多对象的，逗号分隔的，没有明确用符号定义的这些集合默认的类型都是元组
* 所有函数返回的多对象(不包括由列表符号等符号封装的)都是元组类型

### 单元素元组

可以创建单元素列表，但是不能创建单元素元组：

~~~

 >>> ("hello")
 hello

~~~

该语句只是创建了一个'hello'字符串，因为圆括号被重载了，它被用作分组操作符。由圆括号包裹的一个单一元素首先被作为分组操作，而不是作为元组的分界符。一个变通的方法是在第一个元素后面添一个逗号(,)来表明这是一个元组而不是在做分组操作。

### 相关模块

array	
:   一种受限制的可变序列类型,要求所有的元素必须都是相同的类型。

copy	
:   提供浅拷贝和深拷贝的能力

operator	
:   包含函数调用形式的序列操作符，比如operator.concat(m,n)就相当于连接操作(m+n)。

rePerl	
:   风格的正则表达式查找(和匹配)

StringIO/cStringIO	
:   把长字符串作为文件来操作，比如read(),seek()函数等,C版的更快一些,但是它不能被继承.

Textwrap	
:   用作包裹/填充文本的函数，也有一个类[a]

types	
:   包含Python支持的所有类型

collections	
:   高性能容器数据类型\[b\]

a.Python2.3新加	    
b.Python2.4新加


## Python对象的浅拷贝和深拷贝 

对一个对象进行浅拷贝其实是新创建了一个类型跟原对象一样的变量,其内容是原来对象元素的引用。

序列类型对象的浅拷贝是默认类型拷贝,并可以以下几种方式实施:

* 完全切片操作[:]
* 利用工厂函数,比如 list(),dict()等
* 使用copy模块的copy函数

完全拷贝/深拷贝是创建一个新的容器对象,包含原有对象元素（引用）全新拷贝的引用。使用copy.deepcopy()函数实现深拷贝。

注意：非容器类型(比如数字,字符串和其他"原子"类型的对象,像代码,类型和 xrange 对象等)没有被拷贝一说,浅拷贝是用完全切片操作来完成的.如果元组变量只包含原子类型对象,对它的深拷贝将不会进行.

### copy模块

copy模块中只有两个函数可用:copy()进行浅拷贝操作,而deepcopy()进行深拷贝操作.

