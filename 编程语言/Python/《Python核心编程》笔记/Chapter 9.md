# Chapter 9 {#chapter_9}

## 文件内建函数open()和file()

内建函数**open()**以及**file()**提供了初始化输入/输出(I/O)操作的通用接口，**open()**内建函数成功打开文件后时候会返回一个文件对象，如果操作失败，Python会产生一个IOError异常。

## 内建函数open()

~~~

file_object = open(file_name, access_mode='r', buffering=-1)

~~~

**file_name**:包含要打开的文件名字的字符串,它可以是相对路径或者绝对路径.    
**access_mode**:可选参数,是一个字符串,代表文件打开的模式    
**buffering**:可选参数,用于指示访问文件所采用的缓冲方式.其中0表示不缓冲,1表示只缓冲一行数据,任何其它大于1的值代表使用给定值作为缓冲区大小.不提供该参数或者给定负值代表使用系统默认缓冲机制       

文件对象的访问模式access_mode:

------- ---------------------------------------------------
r       以读方式打开
rU      或Ua以读方式打开,同时提供通用换行符支持(PEP278)
w       以写方式打开(必要时清空)
a       以追加模式打开(从EOF开始,必要时创建新文件)
r+      以读写模式打开
w+      以读写模式打开(参见w)
a+      以读写模式打开(参见a)
rb      以二进制读模式打开
wb      以二进制写模式打开(参见w)
ab      以二进制追加模式打开(参见a)
rb+     以二进制读写模式打开(参见r+)
wb+     以二进制读写模式打开(参见w+)
ab+     以二进制读写模式打开(参见a+)
------- ---------------------------------------------------

## 工厂函数file()

**open()**和**file()**函数具有相同的功能,可以任意替换.任何使用open()的地方,都可以使用file()替换它.(在Python 3中不支持**file()**工厂函数)。

## 通用换行符支持(UNS)

Python2.3引入了UNS，用于处理不同平台表示行结束的符号的不同。

当使用**'U'**标志打开文件的时候,所有的行分割符通过Python的输入方法(例如read())返回时都会被替换为换行符NEWLINE(\n).('rU'模式也支持'rb'选项).这个特性还支持包含不同类型行结束符的文件.文件对象的newlines属性会记录文件的行结束符.

如果文件刚被打开,程序还没有遇到行结束符,那么文件的newlines为None.在第一行被读取后,它被设置为第一行的结束符.如果遇到其它类型的行结束符,文件的newlines会成为一个包含每种格式的元组.注意UNS只用于读取文本文件.没有对应的处理文件输出的方法。

## 文件内建方法

### 输入操作

**read()**方法用来直接读取字节到字符串中,最多读取给定数目个字节.如果没有给定size参数(默认值为-1)或者size值为负,文件将被读取直至末尾.

**readline()**方法读取打开文件的一行(读取下个行结束符之前的所有字节).然后整行，包括行结束符，作为字符串返回.和read()相同,它也有一个可选的size参数,默认为-1,代表读至行结束符.如果提供了该参数,那么在超过size个字节后会返回不完整的行。

**readlines()**方法并不像其它两个输入方法一样返回一个字符串.它会读取所有(剩余的)行然后把它们作为一个字符串列表返回.它的可选参数size代表返回的最大字节大小.如果它大于0,那么返回的所有行应该大约有sizhint字节(可能稍微大于这个数字,因为需要凑齐缓冲区大小)。

### 输出操作

**write()**内建方法功能与read()和readline()相反.它把含有文本数据或二进制数据块的字符串写入到文件中去.

**writelines()**和readlines()一样，writelines()方法是针对列表的操作,它接受一个字符串列表作为参数,将它们写入文件.行结束符并不会被自动加入,所以如果需要的话,你必须在调用writelines()前给每行结尾加上行结束符.

注意：
当使用输入方法如read()或者readlines()从文件中读取行时,Python并不会删除行结束符.这个操作被留给了程序员。类似地,输出方法write()或writelines()也不会自动加入行结束符.应该在向文件写入数据前自己完成。

### 文件内移动

**seek()** (类似C中的fseek()函数)可以在文件中移动文件指针到不同的位置.offset字节代表相对于某个位置偏移量.位置的默认值为0,代表从文件开头算起(即绝对偏移量),1代表从当前位置算起,2代表从文件末尾算起.

**text()**方法是对seek()的补充，它告诉你当前文件指针在文件中的位置：从文件起始算起,单位为字节。(Python 3中没有text方法)

### 文件迭代

在Python2.2中,引进了迭代器和文件迭代，这意味着用户不必调用read()方法就可以在for循环中迭代文件的每一行.另外也可以使用迭代器的next方法,file.next()可以用来读取文件的下一行.和其它迭代器一样,Python也会在所有行迭代完成后引发StopIteration异常

一行一行访问文件：

~~~

for eachLine in fileObj:
    print eachLine

# eachLine代表文本文件的一行(包括末尾的行结束符)。

~~~

### 其他操作

**close()**通过关闭文件来结束对它的访问.Python垃圾收集机制也会在文件对象的引用计数降至零的时候自动关闭文件.这在文件只有一个引用时发生。     
**fileno()**方法返回打开文件的描述符.这是一个整数,可以用在如os模块(os.read())的一些底层操作上       
**flush()**方法会直接把内部缓冲区中的数据立刻写入文件,而不是被动地等待输出缓冲区被写入.isatty()是一个布尔内建函数,当文件是一个类tty设备时返回True,否则返回False.**truncate()**方法将文件截取到当前文件指针位置或者到给定size,以字节为单位。        

### 文件方法杂项

不同的操作系统之间的行分隔符存在差异，同时不同系统之间的路径分隔符也存在差异。Python的os模块设计者已经帮我们想到了这些问题.os模块有五个很有用的属性:

**linesep**用于在文件中分隔行的字符串       
**sep**用来分隔文件路径名的字符串       
**pathsep**用于分隔文件路径的字符串     
**curdir**当前工作目录的字符串名称(.)       
**pardir**(当前工作目录的)父目录字符串名称(..)      

注意：
print语句默认在输出内容末尾后加一个换行符,而在语句后加一个逗号就可以避免这个行为.readline()和readlines()函数不对行里的空白字符做任何处理。

### 文件对象的内建方法列表

**file.close()**关闭文件        
**file.fileno()**返回文件的描述符(filedescriptor,FD,整数值)     
**file.flush()**刷新文件的内部缓冲区        
**file.isatty()**判断file是否是一个类tty设备        
**file.next()**返回文件的下一行(类似于file.readline()),或在没有其它行时引发StopIteration异常[a]     
**file.read(size=-1)**从文件读取size个字节,当未给定size或给定负值的时候,读取剩余的所有字节,然后作为字符串返回       
**file.readinto(buf,size)**从文件读取size个字节到buf缓冲器(已不支持)[b]     
**file.readline(size=-1)**从文件中读取并返回一行(包括行结束符),或返回最大size个字符     
**file.readlines(sizhint=0)**读取文件的所有行并作为一个列表返回(包含所有的行结束符);如果给定sizhint且大于0,那么将返回总和大约为sizhint字节的行(大小由缓冲器容量的下一个值决定）（比如说缓冲器的大小只能为4K的倍数，如果sizhint为15k，则最后返回的可能是16k)       
**file.xreadlines()**用于迭代,可以替换readlines()的一个更高效的方法[c]      
**file.seek(off,whence=0)**在文件中移动文件指针,从whence(0代表文件其始,1代表当前位置,2代表文件末尾)偏移off字节      
**file.tell()**返回当前在文件中的位置       
**file.truncate(size=file.tell())**截取文件到最大size字节,默认为当前文件位置        
**file.write(str)**向文件写入字符串     
**file.writelines(seq)**向文件写入字符串序列seq;seq应该是一个返回字符串的可迭代对象;在2.2前,它只是字符串的列表      

a.Python2.2中新增       
b.Python1.5.2中新增,不再支持        
c.Python2.1中新增,在Python2.3中废弃     

### 文件内建属性

文件对象除了方法之外，还有一些数据属性.这些属性保存了文件对象相关的附加数据.

文件对象的属性

**file.closed** True表示文件已经被关闭,否则为False      
**file.encoding** 文件所使用的编码-当Unicode字符串被写入数据时,它们将自动使用file.encoding转换为字节字符串;若file.encoding为None时使用系统默认编码[a]       
**file.mode** 文件打开时使用的访问模式
**file.name** 文件名        
**file.newlines** 未读取到行分隔符时为None,只有一种行分隔符时为一个字符串,当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束符的列表[a]       
**file.softspace** 为0表示在输出一行数据后，要加上一个空格符，1表示不加。   

a.  New in Python 2.3

## 标准文件

一般说来,只要程序一执行,那么就可以访问三个标准文件.它们分别是标准输入(一般是键盘),标准输出(到显示器的缓冲输出)和标准错误(到屏幕的非缓冲输出),分别为**stdin**,**stdout**和**stderr**。
Python中可以通过sys模块来访问这些文件的句柄.导入sys模块以后,就可以使用sys.stdin,sys.stdout和sys.stderr访问.print语句通常是输出到sys.stdout;而内建raw_input()则通常从sys.stdin接受输入(Python3中row_input不再使用)

## 命令行参数
sys模块通过sys.argv属性提供了对命令行参数的访问，在Python中,len(sys.argv)其实就是sys.argv列表的长度,而该列表的第一项sys.argv[0]永远是程序的名称。

## 文件系统

对文件系统的访问大多通过Python的os模块实现,该模块是Python访问操作系统功能的主要接口.os模块实际上只是真正加载的模块的前端,而真正的那个"模块"明显要依赖与具体的操作系统.这个"真正"的模块可能是以下几种之一:posix(适用于Unix操作系统),nt(Win32),mac(旧版本的MacOS),dos(DOS),os2(OS/2),等。不需要直接导入这些模块.只要导入os模块,Python会选择正确的模块。

除了对进程和进程运行环境进行管理外,os模块还负责处理大部分的文件系统操作，这些功能包括删除/重命名文件,遍历目录树,以及管理文件访问权限等。

### os模块的文件/目录访问函数

#### 文件处理 

**mkfifo()/mknod()** 创建命名管道/创建文件系统节点[a]
**remove()/unlink()** 删除文件
**rename()/renames()** 重命名文件[b]
**stat()** 返回文件信息[c]
**symlink()** 创建符号链接
**utime()** 更新时间戳
**tmpfile()** 创建并打开('w+b')一个新的临时文件
**walk()** 遍历一个目录[a]

#### 目录/文件夹

**chdir()/fchdir()** 改变当前工作目录/通过一个文件描述符改变当前工作目录[a]
**chroot()** 改变当前进程的根目录[d]
**listdir()** 列出指定目录的文件
**getcwd()/getcwdu()** 返回当前工作目录/功能相同,但返回一个Unicode对象[a]
**mkdir()/makedirs()** 创建目录/创建多层目录
**rmdir()/removedirs()** 删除目录/删除多层目录

#### 访问/权限

**access()** 检验权限模式
**chmod()** 改变权限模式
**chown()/lchown()** 改变owner和groupID/功能相同,但不会跟踪链接[a]
**umask()** 设置默认权限模式

#### 文件描述符操作

**open()** 底层的操作系统open(对于文件,使用标准的内建open()函数)
**read()/write()** 根据文件描述符读取/写入数据
**dup()/dup2()** 复制文件描述符号/功能相同,但是是复制到另一个文件描述符

#### 设备号

**makedev()** 从major和minor设备号创建一个原始设备号[a]
**major()/minor()** 从原始设备号获得major/minor设备号[a]

a.NewinPython2.3.   
b.NewinPython1.5.2.     
c.Includesstat(),lstat(),xstat().       
d.NewinPython2.2.       

另一个模块os.path可以完成一些针对路径名的操作它提供的函数可以完成管理和操作文件路径名中的各个部分,获取文件或子目录信息,文件路径查询等操作

#### os.path模块中的路径名访问函数

**basename()** 去掉目录路径,返回文件名
**dirname()** 去掉文件名,返回目录路径
**join()** 将分离的各部分组合成一个路径名
**split()** 返回(dirname(),basename())元组
**splitdrive()** 返回(drivename,pathname)元组
**splitext()** 返回(filename,extension)元组

##### 信息

**getatime()** 返回最近访问时间
**getctime()** 返回文件创建时间
**getmtime()** 返回最近文件修改时间
**getsize()** 返回文件大小(以字节为单位)

##### 查询

**exists()** 指定路径(文件或目录)是否存在
**isabs()** 指定路径是否为绝对路径
**isdir()** 指定路径是否存在且为一个目录
**isfile()** 指定路径是否存在且为一个文件
**islink()** 指定路径是否存在且为一个符号链接
**ismount()** 指定路径是否存在且为一个挂载点
**samefile()** 两个路径名是否指向同个文件

这两个模块提供了与平台和操作系统无关的统一的文件系统访问方法。

## 永久存储模块

大部分永久性储存模块是用来储存字符串数据的,但是也有方法来归档Python对象。

### pickle和marshal模块

Python提供了许多可以实现最小化永久性储存的模块.其中的一组(marshal和pickle)可以用来转换并储存Python对象.该过程将把基本类型复杂的对象转换为一个二进制数据集合,这样就可以把数据集合保存起来或通过网络发送,然后再重新把数据集合恢复原来的对象格式.这个过程也被称为数据的扁平化,数据的序列化,或者数据的顺序化.另外一些模块(dbhash/bsddb,dbm,gdbm,dumbdbm等)以及它们的"管理器"(anydbm)只提供了Python字符串的永久性储存.而最后一个模块(shelve)则两种功能都具备。

### pickle模块

pickle模块把Python对象直接保存到文件里,而不需要把它们转化为字符串,也不用底层的文件访问操作把它们写入到一个二进制文件里.pickle模块会创建一个Python语言专用的二进制格式,你不需要考虑任何文件细节,它会帮你干净利索地完成读写对象操作,唯一需要的只是一个合法的文件句柄。

pickle模块中的两个主要函数是dump()和load().dump()函数接受一个文件句柄和一个数据对象作为参数,把数据对象以特定格式保存到给定文件里.当我们使用load()函数从文件中取出已保存的对象时,pickle知道如何恢复这些对象到它们本来的格式。

这些模块本身并没有提供"永久性储存"的功能,因为它们没有为对象提供名称空间,也没有提供对永久性储存对象的并发写入访问(concurrent write access).它们只能储存转换Python对象。

marshal 和 pickle 模块的区别在于marshal只能处理简单的Python对象(数字,序列,映射,以及代码对象),而pickle还可以处理递归对象,被不同地方多次引用的对象,以及用户定义的类和实例.pickle模块还有一个增强的版本cPickle,使用C实现了相关的功能

DBM风格的模块
**db**系列的模块使用传统的DBM格式写入数据,Python提供了DBM的多种实现:dbhash/bsddb,dbm,gdbm,以及dumbdbm等。anydbm模块会自动检测系统上已安装的DBM兼容模块，选择最合适的。

dumbdbm模块是功能最少的一个,在没有其它模块可用时,anydbm才会选择它.这些模块为用户的对象提供了一个命名空间,这些对象同时具备字典对象和文件对象的特点.不过不足之处在于它们只能储存字符串,不能对Python对象进行序列化

shelve 模块
shelve模块使用anydbm模块寻找合适的DBM模块,然后使用cPickle来完成对储存转换过程.shelve模块允许对数据库文件进行并发的读访问,但不允许共享读/写访问。

## 相关模块

### 文件相关模块

**base64** 提供二进制字符串和文本字符串间的编码/解码操作        
**binascii**提供二进制和ASCII编码的二进制字符串间的编码/解码操作        
**bz2** 访问BZ2格式的压缩文件[a]        
**csv** 访问csv文件(逗号分隔文件)[a]        
**filecmp** 用于比较目录和文件[b]       
**fileinput** 提供多个文本文件的行迭代器，该模块遍历一组输入文件,每次读取它们内容的一行,类似Perl语言中的不带参数的"<>"操作符.如果没有明确给定文件名,则默认从命令行读取文件名。     
**getopt/optparse** 提供了命令行参数的解析/处理[a]      
**glob/fnmatch** 提供Unix样式的通配符匹配的功能，glob和fnmatch模块提供了老式Unixshell样式文件名的模式匹配,例如使用星号(\*)通配符代表任意字符串,用问号(?)匹配任意单个字符。        
**gzip/zlib** 读写GNUzip(gzip)文件(压缩需要zlib模块)。gzip和zlib模块提供了对zlib压缩库直接访问的接口.gzip模块是在zlib模块上编写的,不但实现了标准的文件访问,还提供了自动的gzip压缩/解压缩.bz2类似于gzip,用于操作bzip压缩的文件。).     
**shutil** 提供高级文件访问功能，shutil模块提供高级的文件访问功能,包括复制文件,复制文件的访问权限,递归地目录树复制。       
**c/StringIO** 对字符串对象提供类文件接口      
**tarfile** 读写TAR归档文件,支持压缩文件，tarfile文件实现了针对tar归档文件的相同功能[a]     
**tempfile** 创建一个临时文件(名)        
**uu** 格式的编码和解码        
**zipfile** 用于读取ZIP归档文件的工具，zipfile模块创建,修改和读取zip归档文件[c]     

a.NewinPython2.3        
b.NewinPython2.0        
c.NewinPython1.6        

## 使用**os.path.expanduser()**的波浪号(~)进行扩展

虽然glob和fnmatch提供了Unix样式的模式匹配,但它们没有提供对波浪号(用户目录)字符,~的支持.可以使用os.path.expanduser()函数来完成这个功能,传递一个带波浪号的目录,然后返回对应的绝对路径。
