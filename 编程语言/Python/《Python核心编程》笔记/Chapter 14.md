# Chapter 14 {#chapter_14}

## 可调用对象

许多的python对象都是我们所说的可调用的，即是任何能通过函数操作符()来调用的对象。要调用可调用对象，函数操作符得紧跟在可调用对象之后。Python有4种可调用对象：

* 函数
* 方法
* 类
* 一些类的实例。

### 函数

python有3种不同类型函数对象。

内建函数
:   BIF是用c/c++写的，编译过后放入python解释器，
    然后把它们作为内建名字空间的一部分加载进系统。

    内建函数属性

    bif.\_\_doc\_\_		
    :	文档字符串（或None)
    
    bif.\_\_name\_\_	
    :	字符串类型的文档名字

    bif.\_\_self\_\_	
    :	设置为None（保留给built-in方法）

    bif.\_\_module\_\_	
    :	存放bif定义的模块名字(或None)

用户定义的函数
:   UDF通常是用python写的，定义在模块的全局名字空间中，
    因此会作为全局名字空间的一部分装载到系统中。函数也可以内建在函数体内。

    用户自定义函数属性
    udf.\_\_doc\_\_	
    :	文档字符串(也可以用udf.func_doc)

    udf.\_\_name\_\_	
    :	字符串类型的函数名字（也可以用udf.func_name)

    udf.\_\_code\_\_
    :	字节编译的代码对象

    udf.\_\_defaults\_\_
    :	默认的参数元组

    udf.\_\_globals\_\_
    :	全局名字空间字典；和从函数内部调用globals(x)一样

    udf.\_\_dict\_\_		
    :	函数属性的名字空间

    udf.\_\_doc\_\_
    :	见上面的udf.\_\_doc\_\_

    udf.\_\_name\_\_
    :	见上面的udf.\_\_name\_\_

    udf.\_\_closure\_\_
    :	包含了自由变量的引用的单元对象元组

    lambda表达式和用户自定义对函数相比，略有不同。虽然它们也是返回一个函数对象，但是lambda表达式不是用def语句创建的，而是用lambda关键字
    因为lambda表达式没有给命名绑定的代码提供基础结构，所以要通过函数式编程接口来调用，
    或把它们的引用赋值给一个变量，然后就可以直接调用或者再通过函数来调用。变量仅是个别名，并不是函数对象的名字。
    通过lambda来创建函数的对象除了没有命名之外，享有和用户自定义函数相同的属性；\_\_name\_\_或者func_name属性给定为字符串"<lambda>"

### 方法

内建方法(BIMs)
:   内建方法（BIM）属性 

    bim.\_\_doc\_\_	
    :	文档字串 
    bim.\_\_name\_\_
    :	字符串类型的函数名字 

    bim.\_\_self\_\_
    :	绑定的对象 

    BIM和BIF两者也都享有相同属性。
    不同之处在于BIM的\_\_self\_\_属性指向一个Python对象，而BIF指向None。


用户定义的方法（UDM）
:   UDM包含在类定义之中，只是拥有标准函数的包装，仅有定义它们的类可以使用。
    如果没有在子类定义中被覆盖掉，也可以通过子类实例来调用它们。

    用户自定义方法的属性

    udm.\_\_doc\_\_	
    :	文档字符串（与udm.im_fuc.\_\_doc\_\_相同）

    udm.\_\_name\_\_
    :	字符串类型的方法名字（与umd.im_func.\_\_name\_\_相同）

    udm.\_\_module\_\_	
    :	定义udm的模块的名字(或none)

    udm.\_\_class\_\_	
    :	方法相关联的类（对于绑定的方法；如果是非绑定，那么为要求udm的类）

    udm.\_\_func\_\_	
    :	方法的函数对象（见UDFs）

    udm.\_\_self\_\_	
    :	如果绑定的话为相关联的实例，如果非绑定位为none


### 类

类有默认构造函数，该函数什么都不做，基本上只有一个pass语句。程序员可以通过实现\_\_int\_\_()方法，来自定义实例化过程。

### 类的实例

python给类提供了名为\_\_call\_\_的特别方法，该方法允许程序员创建可调用的对象（实例）。默认情况下，\_\_call\_\_()方法是没有实现的，这意味着大多数实例都是不可调用的。然而，如果在类定义中覆盖了这个方法，那么这个类的实例就成为可调用的了。调用这样的实例对象等同于调用\_\_call\_\_()方法。自然地，任何在实例调用中给出的参数都会被传入到\_\_call()\_\_中。

只有定义类的时候实现了\_\_call\_\_方法，类的实例才能成为可调用的。

## 代码对象

每个可调用对象的核心都是代码对象，由语句，赋值，表达式，以及其他可调用对象组成。可调用对象又可以递归分解到下一层，每一层都有自己的代码对象。

一般说来，代码对象可以作为函数或者方法调用的一部分来执行，也可用**exec**语句或内建函数**eval()**来执行。从整体上看，一个python模块的代码对象是构成该模块的全部代码。

如果要执行python代码，那么该代码必须先要转换成字节编译的代码（又称字节码）。这才是真正的代码对象。然而，它们不包含任何关于它们执行环境的信息，而可调用对象存在的目的，是被用来包装一个代码对象并提供额外的信息。

UDF的udf.\_\_code\_\_属性就是代码对象。函数对象仅是代码对象的包装，方法则是给函数对象的包装。

## 可执行的对象声明和内建函数

Python提供了大量的BIF来支持可调用/可执行对象，其中包括**exec**语句。这些函数帮助程序员执行代码对象，也可以用内建函数**complie()**来生成代码对象。

### 可执行对象和内建函数 

**callable(obj)**
:   如果obj可调用，返回True，否则返回FALSE

**compile(string,file,type)**
:   从type类型中创建代码对象。

    compile的三个参数都是必需的：
    * 第一参数代表了要编译的python代码。
    * 第二个字符串，虽然是必需的，但通常被置为空串。该参数代表了存放代码对象的文件的名字(字符串类型）。
      compile的通常用法是动态生成字符串形式的Python代码，然后生成一个代码对象。
    * 最后的参数是个字符串，它用来表明代码对象的类型。有三个可能值：
	* 'eval' - 可求值的表达式[和eval()一起使用]
	* 'single' - 单一可执行语句[和exec一起使用]
	* 'exec' - 可执行语句组[和exec一起使用]

    compile()函数允许程序员在运行时刻迅速生成代码对象，然后就可以用exec语句或者内建函数eval()来执行这些对象或者对它们进行求值。
    一个很重要的特点是：exec和eval()都可以执行字符串格式的Python代码。
    当执行字符串形式的代码时，每次都必须对这些代码进行字节编译处理。compile()函数提供了一次性字节代码预编译，以后每次调用的时候，都不用编译了。

**eval(obj,globals=globals(),locals=locals())**
:   对obj进行求值，obj是已编译为代码对象的表达式，或是一个字符串表达式；可以给出全局或者/和局部的名字空间
    exec执行obj、单一的python语句或者语句的集合，也就是说格式是代码对象或者字符串；
    obj也可以是一个文件对象（已经打开的有效python脚本）

    eval()对表达式求值，第一个参数可以为字符串或内建函数complie()创建的预编译代码对象。
    第二个和第三个参数，都为可选的，分别代表了全局和局部名字空间中的对象。
    如果给出这两个参数，globals必须是个字典，locals可以是任意的映射对象，比如，一个实现了\_\_getitem\_\_()方法的对象。
    如果都没给出这两个参数，分别默认为globals()和locals()返回的对象，如果只传入了一个全局字典，那么该字典也作为locals传入。


**exec**
:   和eval()相似，exec语句执行代码对象或字符串形式的python代码。
    类似地，用compile()预编译重复代码有助于改善性能，因为在调用时不必经过字节编译处理。exec语句只接受一个参数，
    下面便是它的通用语法：
	exec obj	(在Python 3中，需要使用exec(obj)执行)

    被执行的对象(obj)可以只是原始的字符串，比如单一语句或是语句组，它们也可以预编译成一个代码对象（分别用'single'和'exec"参数)。
    exec还可以接受有效的python文件对象，但是，注意一旦执行完毕，继续对exec的调用就会失败。
    事实上，exec已从文件中读取了全部的数据且停留在文件末尾(EOF)。
    当用相同文件对象对exec进行调用的时候，便没有可以执行的代码了，所以exec什么都不做。(注意：在Python3中，exec不支持文件对象)

**input()**
:   内建函数input()是eval()和raw_input()的组合，等价于eval(raw_input())。
    类似于raw_input()，input()有一个可选的参数，该参数代表了给用户的字符串提示。如果不给定参数的话，该字符串默认为空串。
    从功能上看，input不同于raw_input()，因为raw_input()总是以字符串的形式，逐字地返回用户的输入。
    input()履行相同的的任务，而且，它还把输入作为python表达式进行求值。这意味着input()返回的数据是对输入表达式求值的结果：一个python对象。

## 执行其他（Python）程序

### 导入

在运行时刻，有很多执行另外python脚本的方法。第一次导入模块会执行模块最高级的代码。不管你是否需要。如果处理那些不想每次导入都执行的，缩进它，并放入if\_\_name\_\_=='\_\_main\_\_'的内部。

**execfile()**
:   execfile()用于执行一个文件对象中的代码。（Python3中不支持）

~~~

 >>> f = open(filename, 'r')
 >>> exec f 
 >>> f.close()

可被替换为

 >>> execfile(filename)

~~~

虽然上述代码执行了一个模块，但是仅可以在现有的执行环境下运行。在某些情况下，可能需要用不同全局和局部的名字空间集合，而不是默认的集合来执行模块。execfile()函数的语法非常类似于eval()函数的。

~~~

execfile(filename, globals=globals(), locals=locals())

~~~

类似eval()，globals和locals都是可选的，如果不提供参数值的话，默认为执行环境的名字空间。如果只给定globals，那么locals默认和globals相同。如果提供locals值的话，它可以是任何映射对象(一个定义/覆盖了\_\_getitem\_\_()的对象)。execfile()不保证不会修改局部名字空间。

### 将模块作为脚本执行

如果没给出完全的路径名，可以从命令行运行一个模块，并让 python 的导入机制来进行路径查找，这时，可以使用Python的**-c**选项。

~~~

$ python -c "import CGIHTTPServer; CGIHTTPServer.test()"

~~~

该选项允许你指定你想要运行的 python 语句。虽然它可以这样工作，但问题是\_\_name\_\_的值不是‘\_\_main\_\_’，而是正在使用的模块的名字。

能够在类库中执行作为脚本的模块而不是作为导入的模块。**-m** 参数可以实现这种需求：

~~~

$ python -m CGIHTTPServer

~~~

## 执行其他（非Python）程序

在python程序里我们也可以执行非python程序。这些程序包括了二进制可执行文件，其他的shell脚本等等。

所有的要求只是一个有效的执行环境，比如，允许文件访问和执行，脚本文件必须能访问它们的解释器(perl,bash,等等），二进制必须是可访问的。

### 执行环境相关模块

atexit
:   注册当python解释器退出时候的执行句柄[a]

popen2
:   提供额外的在os.popen之上的功能：（提供通过标准文件和其他的进程交互的能力；对于python2.4和更新的版本，使用subpross）

commands
:   提供额外的在os.system之上的功能：把所有的程序输出保存在返回的字符串中（与输出到屏幕的相反）；对于python2.4和更新的版本，使用subpross○[U]

getopt
:   在这样的应用程序中的处理选项和命令行参数

site
:   处理site-specific模块或包

platform
:   底层平台和架构的属性[b]

subprocess
:   管理（计划替代旧的函数和模块，比如os.system()，os.spawn*()，os.popen*()，popen2.*,command.*)[c]

a.python2.0时加入
b.python2.3时加入
c.python2.4时加入
[u]-Unix
[W]-Windows
