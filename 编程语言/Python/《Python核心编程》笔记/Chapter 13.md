# Chapter 13 {#chapter_13}

## 类和实例

Python中，所有的类都是**object**类的子类，如果在类定义的时候没有显式声明父类，则默认为**object**类，**object**类位于所有类继承结构的最上层。

~~~

class MyNewObjectType(bases): 
	'define MyNewObjectType class' 
	class_suite  #类体

~~~

参数 *base* 是一个(单继承)或多个(多继承)用于继承的父类。如果没有指定继承的父类，则可以定义一个经典类：

~~~

class MyNewObjectType: 
	'define MyNewObjectType classic class' 
	class_suite 

~~~

创建一个实例的过程称作实例化，实例化一个类：

~~~

instance = classType()

~~~

### 定义方法

~~~

class MyDataWithMethod(object):  # 定义类 
	def printFoo(self):  # 定义方法 
		print 'You invoked printFoo()!'

~~~

 *self* 参数：它在所有的方法声明中都存在。这个参数代表实例对象本身，当用实例调用方法时，由解释器悄悄地传递给方法的，所以不需要自己传递self进来，因为它是自动传入的。

在Python中，Python创建实例后，在实例化过程中，调用\_\_init\_\_()方法，当一个类被实例化时，就可以定义额外的行为，比如，设定初始值或者运行一些初步诊断代码。\_\_init\_\_()在实例化时被调用，传递给类的参数被传递给了\_\_init\_\_()函数。

~~~

class MyClass(object):
    def __init__(self, arg1, arg2):
	pass

obj = MyClass(arg1, arg2)

~~~

### 命名类、属性和方法

类名通常由大写字母打头，数据值应该使用名词作为名字，方法使用谓词（动词加对象）。也可以使用下划线分割名字。

## 类

### 创建类

Python类使用**class**关键字来创建。

~~~

class ClassName(object): 
	'class documentation string'  #类文档字符串 
	class_suite    #类体 

~~~

尽管类是对象（在Python中，一切皆对象），但正被定义时，它们还不是对象的实现。

### 声明与定义

对于 Python来说，声明与定义类没什么区别，他们是同时进行的，定义（类体）紧跟在声明（含class关键字的头行)和可选(但总是推荐使用)的文档字符串后面。同时，所有的方法也必须同时被定义。注意Python并不支持纯虚函数（像C++）或者抽象方法（如在JAVA中）。作为替代方法，可以简单地在基类方法中引发**NotImplementedError**异常，这样可以获得类似的效果。

### 类属性

类属性仅与其被定义的类相绑定。

#### 类的数据属性

数据属性仅仅是所定义的类的变量。它们可以像任何其它变量一样在类创建后被使用。并且，要么是由类中的方法来更新，要么是在主程序其它什么地方被更新。

这种属性即静态变量，或者是静态数据。它们表示这些数据是与它们所属的类对象绑定的，不绑定于任何类实例。

#### 方法

##### 绑定

Python严格要求，没有实例，方法是不能被调用的。这种限制即Python所描述的**绑定**概念(binding)，在此，方法必须绑定（到一个实例）才能直接被调用。非绑定的方法可能可以被调用，但实例对象一定要明确给出，才能确保调用成功。然而，不管是否绑定，方法都是它所在的类的固有属性，即使它们总是通过实例来调用的。

### 获取类的属性

知道一个类有哪些属性，有两种方法。最简单的是使用**dir()**内建函数。另外是通过访问类的字典属性**\_\_dict\_\_**，这是所有类都具备的特殊属性之一。

* dir()返回一个对象的属性的名字列表
* \_\_dict\_\_返回的是一个字典，它的键(keys)是属性名，键值(values)是相应的属性对象的数据值。内建的**vars()**函数接受类对象作为参数，返回类的\_\_dict\_\_属性。

内建类型也是类，但是内建类型没有\_\_dict\_\_属性。

### 特殊的类属性

Class.\_\_name\_\_
:   类Class的名字（字符串） 
    \_\_name\_\_是给定类的字符名字。它适用于那种只需要字符串（类对象的名字），而非类对象本身的情况。甚至一些内建的类型也有这个属性。

Class.\_\_doc\_\_
:   类Class的文档字符串 
    \_\_doc\_\_是类的文档字符串，与函数及模块的 文档字符串相似，
    必须紧随头行后。文档字符串不能被派生类继承，也就是说派生类必须含有它们自己的文档字符串。

Class.\_\_bases\_\_      
:   类Class的所有父类构成的元组 

Class.\_\_dict\_\_       
:   类Class的属性 
    \_\_dict\_\_属性包含一个字典，由类的数据属性组成。访问一个类属性的时候，Python 解释器将会搜索字典以得到需要的属性。
    如果在\_\_dict\_\_中没有找到，将会在基类的字典中进行搜索，采用“深度优先搜索”顺序。
    基类集的搜索是按顺序的，从左到右，按其在类定义时，定义父类参数时的顺序。对类的修改会仅影响到此类的字典；基类的\_\_dict\_\_属性不会被改动的。

Class.\_\_module\_\_  
:   类Class定义所在的模块（1.5 版本新增） 
    \_\_module\_\_属性，Python支持模块间的类继承。为更清晰地对类进行描述，1.5版本中引入了\_\_module\_\_，这样类名就完全由模块名所限定。

## 实例

实例化的实现，可以使用函数操作符:

~~~

 >>> class MyClass(object):  # define class 定义类 
	    pass 

 >>> mc = MyClass() # instantiate class 初始化类 

~~~

返回的对象是所调用类创建的一个实例。当实例化一个类时，解释器就会创建一个对象，并且调用Python所拥有与构造函数类似的操作来执行最终的定制工作。

### \_\_init\_\_() "构造器"方法

当类被调用，实例化的第一步是创建实例对象。一旦对象创建了，Python检查是否实现了**\_\_init\_\_()**方法。默认情况下，如果没有定义（或覆盖）特殊方法**\_\_init\_\_()**,则对实例不会施加任何特别的操作。任何所需的特定操作，都需要程序员实现**\_\_init\_\_()**，覆盖它的默认行为。如果类中没有定义**\_\_init\_\_()**方法，则返回它的对象，实例化过程完毕。

然而，如果定义了**\_\_init\_\_()**方法，那么它将在创建完实例以后被调用，实例对象作为第一个参数**self**被传递进去，像标准方法调用一样，创建实例时，传进的任何参数都交给了**\_\_init\_\_()**。

**\_\_init\_\_()**是类的特殊方法之一。其中一些特殊方法是预定义的，缺省情况下，不进行任何操作，比如\_\_init\_\_()，要定制，就必须对它进行重载，还有些方法，可能要按需要去实现。

### \_\_new\_\_() “构造器”方法

Python用户可以对内建类型进行派生，因此，需要一种途径来实例化不可变对象，在这种情况下，解释器则调用类的**\_\_new\_\_()**方法，一个类方法，并且传入的参数是在类实例化操作时生成的。**\_\_new\_\_()**会调用父类的**\_\_new\_\_()**来创建对象。**\_\_new\_\_()**必须返回一个合法的实例，这样解释器在调用**\_\_init\_\_()**时，就可以把这个实例作为 **self**参数 传给它。

### \_\_del\_\_() "析构器"方法

由于 Python 具有
垃圾对象回收机制（靠引用计数)，这个函数要直到该实例对象所有的引用都被清除掉后才会执行。Python 中的析构器是在实例释放前提供特殊处理功能的方法。

### 实例属性

实例仅拥有数据属性（方法严格来说是类属性），实例属性只是与实例相关联的数据值，并且可以通过域操作符来访问。当一个实例被释放后，它的属性同时也被清除了。

#### 初始化实例属性

初始化实例属性可以在实例创建后的任意时间进行，构造器**\_\_init()\_\_**是设置这些属性最开始的位置。

Python 能够在“运行时”添加实例属性，而不像Java和C++那样必须先在类定义中声明和定义。但是这种特性使得如果属性在条件语句中创建，如果该条件语句块并未被执行，属性也就不存在，而在后面的代码中试着去访问这些属性，就会有错误发生。

构造器是最早可以设置实例属性的地方，因为\_\_init\_\_()是实例创建后第一个被调用的方法。一旦**\_\_init\_\_()**执行完毕，返回实例对象，即完成了实例化过程。

在实际应用中，带默认参数的**\_\_init\_\_()**提供一个有效的方式来初始化实例。需要注意一点，默认参数应当是不变的对象，像列表(list)和字典(dictionary)这样的可变对象可以扮演静态数据，然后在每个方法调用中来维护它们的内容。

构造器不能返回任何对象，因为实例对象是自动在实例化调用后返回的。所以**\_\_init\_\_()**构造器返回None，实际上也不需要返回，因为在调用方法的时候是传递实例对象到方法中的，并且是通过引用的方式传递进去的，所以实例是被就地修改的。

#### 查看实例属性

内建函数**dir()**可以显示类属性，同样还可以显示实例属性。

与类相似，实例也有一个**\_\_dict\_\_**特殊属性（可以调用vars()并传入一个实例来获取），它是实例属性构成的一个字典。

##### 特殊的实例属性

instance.\_\_class\_\_ 
:   实例化instance的类（仅仅用于新式类） 

instance.\_\_dict\_\_
:   instance的属性字典
    \_\_dict\_\_属性由一个字典组成，包含一个实例的所有属性。键是属性名，值是属性相应的数据值。字典中仅有实例属性，没有类属性或特殊属性。


## 实例属性和类属性

如果在实例属性中存在和类属性同名的属性，则类属性会被实例属性覆盖，而当实例属性名被从名字空间中删除后，类属性又可以被正常访问。因为当访问一个属性时，如果是通过类名来访问的，则Python在类的名字空间中查找属性，如果是通过实例名来访问的，则Python先在实例所在的名字空间中查找，如果找到，则停止查找，否则向其类的名字空间中查找。

通过实例访问类属性进行增量操作时，如果类属性是不可变对象，则在增量操作时，相当于将类属性的值增加了增量后赋值给实例属性，这就创建了一个新的实例属性，而类属性不变。如果是一个可变对象，则会影响到类属性。

修改类属性的值会影响到所有由这个类实例化的所有实例。

## 绑定和方法调用

方法仅仅是类内部定义的函数，方法是类属性而不是实例属性。其次，方法只有在其所属的类拥有实例时，才能被调用。当存在一个实例时，方法才被认为是绑定到那个实例了。没有实例时方法就是未绑定的。任何一个方法定义中的第一个参数都是变量 **self**，它表示调用此方法的实例对象。

### self变量

**self**变量用于在方法中引用方法所绑定的实例。因为实例在任何方法调用中总是作为第一个参数传递的，**self**被选中用来代表实例。必须在方法声明中放上**self**，但可以在方法中不使用**self**参数，如果没有指定**self**参数，则创建一个常规的函数。

### 调用绑定方法和非绑定方法

通过类访问一个方法时，由于访问的方法没有绑定到一个实例，则调用的是一个非绑定方法，在调用一个非绑定的方法的时候，必须对非绑定的方法传递一个实例参数给**self**。

通过实例访问一个方法时，该方法绑定到了一个实例，这时调用的是一个绑定的方法，不需要传递一个实例对象给**self**参数，因为方法已经是绑定了的。

### 静态方法和类方法

**静态方法**是类中的方法，而其调用不需要实例。

**类方法**需要类而不是实例作为第一个参数，这个参数是由解释器传给类方法的。

#### **staticmethod()**和**classmethod()**内建函数

**staticmethod()**方法将类中的方法转换为静态方法：

~~~

 >>> class TestStaticMethod: 
 	def foo(): 
	    pass

 
 >>> foo = staticmethod(foo) 

~~~

**classmethod()**方法将类中的方法转换为类方法：

~~~

 >>> class TestClassMethod: 
	def foo(cls): 
		print 'calling class method foo()' 
		print 'foo() is part of class:', cls.__name__ 
 
 >>> foo = classmethod(foo)

~~~

#### 使用函数修饰符

除了使用**staticmethod()**方法和**classmethod()**方法转换方法外，还可以使用函数修饰器。

~~~

class TestStaticMethod: 
    @staticmethod 
    def foo(): 
 	print 'calling static method foo()' 
 
class TestClassMethod: 
    @classmethod 
    def foo(cls): 
  	print 'calling class method foo()' 
  	print 'foo() is part of class:', cls.__name__

~~~

## 子类和派生 


### 创建子类

创建子类的语法是一个类名，后跟一个或多个需要从其中派生的父类： 

~~~

class SubClassName (ParentClass1[, ParentClass2, ...]): 
	'optional class documentation string'   
	class_suite 

~~~

每个子类最好定义它自己的构造器，不然，基类的构造器会被调用。然而，如果子类重写基类的构造器，基类的构造器就不会被自动调用了，这样，基类的构造器就必须显式写出才会被执行。

如果类没有从任何祖先类派生，可以使用object作为父类的名字。

### 继承

继承描述了基类的属性如何“遗传”给派生类。一个子类可以继承它的基类的任何属性，不管是数据属性还是方法。

### \_\_bases\_\_属性

“父类”是相对所有基类（它包括了所有祖先类）而言的。那些没有父类的类，它们的**\_\_bases\_\_**属性为空。

### 通过继承覆盖（Overriding）方法 

当子类定义了同名的方法覆盖了父类的方法的时候，只能调用子类覆盖的方法，如果需要调用被覆盖的父类定义的方法，则需要使用调用未绑定的方法的方式调用父类的方法。需要传递给父类一个实例作为父类方法**self**的参数。

可以使用**super()**内建函数实现调用被覆盖的父类方法，**super()**不但能找到基类方法，而且还传进self。

~~~

class C(P): 
	def foo(self): 
		super(C, self).foo() 
		print 'Hi, I am C-foo()'

~~~

注意：重写**\_\_init\_\_**不会自动调用基类的**\_\_init\_\_**。类似于覆盖非特殊方法，当从一个带构造器 **\_\_init()\_\_**的类派生，如果你不去覆盖**\_\_init\_\_()**，它将会被继承并自动调用。但如果你在子类中覆盖了**\_\_init\_\_()**，子类被实例化时，基类的**\_\_init\_\_()**就不会被自动调用。如果你还想调用基类的 **\_\_init\_\_()**，则需要显式调用。

~~~

 >>> class Parent(object):
	def __init__(self, a, b):
		print 'init parent with a = %d b = %d' % (a, b)
		self.a = a
		self.b = b
	def method(self):
		print 'method'

		
 >>> class Child(Parent):
	def __init__(self, a, b):
		super(Child, self).__init__(a, b)
		print 'init child with a = %d b = %d' % (a, b)
	def method(self):
		super(Child, self).method()

 >>> c = Child(1, 2)
 init parent with a = 1 b = 2
 init child with a = 1 b = 2

 >>> c.method()
 method

~~~

### 从标准类型派生

从标准类型派生，需要使用**\_\_new\_\_()**类方法。

#### 从不可变类型派生

~~~

class RoundFloat(float): 
	def __new__(cls, val): 
		return float.__new__(cls, round(val, 2))

~~~

注意，**\_\_new()\_\_**方法是类方法，要显式传入类对象作为第一个参数，这类似于常见的方法如**\_\_init\_\_()**中需要的**self**。

####从可变类型派生

从可变类型派生和派生一个子类类似。

### 多重继承

Python允许子类继承多个基类。这种特性称为**多重继承**。

#### 方法解释顺序(MRO)

在Python2.2以前的版本中，算法非常简单：深度优先，从左至右进行搜索，取找到的第一个名字。

在新式的类中包含了**\_\_mro\_\_**属性，该属性中存储了查找的顺序。对于每个定义的类，都有一个名为**\_\_mro\_\_**的属性，它是一个元组，按照搜索时的顺序，列出了待搜索的类。

## 类、实例和其他对象的内建函数

**issubclass()**
:   **issubclass(subclass, superclass)**函数判断一个类是否是另一个类的子类或子孙类。
    返回值：如果给出的子类subclass确实是父类superclass的一个子类，则返回True，否则返回False
    这个函数也允许“不严格”的子类，意味着，一个类可视为其自身的子类，所以，这个函数如果当subclass就是superclass，或者从superclass派生而来，则返回True。
    从Python2.3开始，issubclass()的第二个参数可以是可能的父类组成的tuple（元组），这时，只要第一个参数是给定元组中任何一个候选类的子类时，就会返回True。

**isinstance()**
:   **isinstance(instance, class)**判断一个实例对象是否是另一个给定类对象的实例。
    返回值：如果instance是类对象class的一个实例，或者instance是类对象class的子类的一个实例时，返回True，否则返回False
    第二个参数应当是类，不然，会得到一个**TypeError**异常。但如果第二个参数是一个类型对象，则不会出现异常。
    这是允许的，因此可以使用isinstance()来检查一个对象instance是否是class类型。
    isinstance()也可以使用一个元组（tuple）作为第二个参数。如果第一个参数是第二个参数中给定元组的任何一个候选类型或类的实例时，就会返回True。

**hasattr(), getattr(),setattr(), delattr()**
:   \*attr()系列函数可以在任何对象中工作，不限于类（class）和实例（instances）。
    需要说明的是，当使用这些函数时，传入正在处理的对象作为第一个参数，但属性名，也就是这些函数的第二个参数，是这些属性的字符串名字。

    * **hasattr(object, attrname)**函数是bool类型的，它的目的就是为了决定一个对象是否有一个指定的属性，一般用于访问某属性前先作一下检查。
    * **getattr(object, name[, default])**获取对象object的属性名为name的属性的值，和object.name这种方式访问属性是等价的。
      如果试图读取一个不存在的属性，会引发**AttributeError**异常，除非给出那个可选的默认参数default。
    * **setattr(object, name, value)**等价于object.name = value，用于设置一个属性的值，如果属性不存在，则添加这个属性。
    * **delattr(object, name)**函数会从一个对象中删除属性，等价于del object.name。

**dir()**
:   dir(object)作用在实例上时，显示实例属性，还有在实例所属的类及这个类所有的基类中定义的方法和类属性。
    dir(object)作用在类上（经典类或新式类）时，则显示类自己以及它的所有基类的\_\_dict\_\_属性的内容。但它不会显示定义在元类（metaclass）中的类属性。
    dir(object)作用在模块上时，则显示模块的\_\_dict\_\_的内容。
    dir(object)不带参数时，则显示调用者的局部变量。

**super()**
:   super(subclass[, instance])函数在 Python2.2 版本新式类中引入。这个函数的目的就是帮助找出子类的父类，方便调用父类相关的属性。 
    给出子类的类对象subclass，super()返回这个子类的父类。如果希望父类被绑定,可以传入instance参数(instance必须是subclass类型的)，否则父类不会被绑定。
    instance参数也可以是一个类对象，但它应当是subclass的一个子类。
    事实上，super()是一个工厂函数，它创造了一个super object，为一个给定的类使用\_\_mro\_\_去查找相应的父类。

**vars()**
:   vars()内建函数与dir()相似，只是传递进去的对象都必须有一个\_\_dict\_\_属性。
    vars()返回一个字典，它包含了对象存储于\_\_dict\_\_中的属性(键)及值。
    如果提供的对象没有这样一个属性，则会引发一个**TypeError**异常。
    如果没有提供参数，它将显示一个包含本地名字空间的属性（键）及其值的字典。


## 用特殊方法定制类

除了**\_\_init\_\_()**和**\_\_del\_\_()**等特殊方法外，Python中存在其他的特殊方法，它们中的一些有预定义的默认行为，而其它一些则没有，留到需要的时候去实现。这些特殊方法是 Python 中用来扩充类的强有力的方式。它们可以实现: 

* 模拟标准类型 
* 重载操作符

这些方法都是以双下划线(\_\_)开始和结尾的。

## 私有化

默认情况下，属性在Python中都是“public”的，类所在模块和导入了类所在模块的其他模块的代码都可以访问到。

### 双下划线(\_\_)

Python为类元素（属性和方法）的私有性提供初步的形式。由双下划线开始的属性在运行时被保护，所以直接访问是不允许的。实际上，会在名字前面加上下划线和类名。把类名加上后形成的新的结果将可以防止在祖先类或子孙类中的同名冲突。

~~~

 >>> class Parent(object):
	def __init__(self):
		self.__private = 12

 >>> p.__dict__
 {'_Parent__private': 12}

~~~

可以看出，双下划线开头的属性是通过拼接类名来实现私有化的。

这种名字混淆的另一个目的,是为了保护\_\_XXX变量不与父类名字空间相冲突。如果在类中有一个\_\_XXX属性，它将不会被其子类中的\_\_XXX属性覆盖。

### 单下划线(\_)

简单的模块级私有化只需要在属性名前使用一个单下划线字符。这就防止模块的属性采用 **from module import * **这种方式来加载。这是严格基于作用域的，所以这同样适合于函数。

## 新式类的高级特性(Python 2.2+)

由于类型和类的统一，这些特性中最重要的是能够子类化Python的内建数据类型。所有的Python内建的转换函数现在都是工厂函数。当这些函数被调用时，你实际上是对相应的类型进行实例化。

### \_\_slots\_\_类属性

**\_\_slots\_\_**是一个类属性，由序列类型组成，由所有合法标识符组成的实例属性的集合来表示。任何试图创建一个其名不在\_\_slots\_\_中的名字的实例属性都将导致**AttributeError**异常。

这种特性的主要目的是节约内存。其副作用是某种类型的"安全"，它能防止用户随心所欲的动态增加实例属性。带**\_\_slots\_\_**属性的类定义不会再存在**\_\_dict\_\_**了（除非你在**\_\_slots\_\_**中增加**\_\_dict\_\_**属性）

### \_\_getattribute\_\_()特殊方法

Python类有一个名为**\_\_getattr\_\_()**的特殊方法，它仅当属性不能在实例的\_\_dict\_\_或它的类（类的\_\_dict\_\_），或者祖先类（其\_\_dict\_\_）中找到时，才被调用。当想要一个适当的函数来执行每一个属性访问，不光是当属性不能找到的情况，这时需要使用\_\_getattribute\_\_()。它使用起来，类似\_\_getattr\_\_()，不同之处在于，当属性被访问时，它就一直可以被调用，而不局限于不能找到的情况。

如果类同时定义了\_\_getattribute\_\_()及\_\_getattr\_\_()方法,除非显式调用\_\_getattr\_\_()，或者\_\_getattribute\_\_()调用引发了**AttributeError**异常,否则\_\_getattr\_\_()不会被调用。

如果需要使用\_\_getattribute\_\_()访问类或其祖先类的属性，那么，如果在\_\_getattribute\_\_()中再次调用了\_\_getattribute\_\_()，将会进入无穷递归。为避免在使用这种方法时引起无穷递归，为了安全地访问任何它所需要的属性,应该显式调用祖先类的同名方法；比如，super(obj,self).\_\_getattribute\_\_(attr)。

## Metaclasses和\_\_metaclass\_\_

元类让你来定义某些类是如何被创建的，从根本上说，赋予你如何创建类的控制权。从根本上说，你可以把元类想成是一个类中类，或是一个类，它的实例是其它的类。实际上，当你创建一个新类时，你就是在使用默认的元类，它是一个类型对象。

元类一般用于创建类。在执行类定义时，解释器必须要知道这个类的正确的元类。解释器会先寻找类属性\_\_metaclass\_\_，如果此属性存在，就将这个属性赋值给此类作为它的元类。如果此属性没有定义，它会向上查找父类中的\_\_metaclass\_\_. 所有新风格的类如果没有任何父类，会从对象或类型中继承。
如果还没有发现\_\_metaclass\_\_属性，解释器会检查名字为\_\_metaclass\_\_的全局变量，如果它存在，就使用它作为元类。否则,这个类就是一个传统类，并用**types.ClassType**作为此类的元类。

## 相关模块和文档

UserList	
:   提供一个列表对象的封装类

UserDict	
:   提供一个字典对象的封装类

UserString	
:   提供一个字符串对象的封装类；它又包括一个MutableString子类，如果有需要，可以提供有关功能[a]

types		
:   定义所有Python对象的类型在标准Python解释器中的名字

operator	
:   标准操作符的函数接口

a.新出现于Python1.6版本
