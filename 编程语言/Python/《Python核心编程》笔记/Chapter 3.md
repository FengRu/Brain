# Chapter 3

## 变量赋值

在Python语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还是一个已经存在的，都将该对象的引用赋值给该变量。

在Python中，赋值语句没有返回值，所以表达式

~~~

y = (x = x + 1)

~~~

是非法的。但是对于链式赋值语句是合法的

~~~

x = y = z + 1

~~~

Python支持算术赋值运算符 *-=、+=、\=.....* 。

对象操作的时候，对于可变对象，对象被就地修改，而对于不可变对象，则会新建一个对象，将这个新对象作为结果。

Python中的元组赋值：

~~~

(x, y, z) = 1, 2, 3

或

x, y, z = 1, 2, 3
~~~

在赋值语句左边的元组的括号是可省略的。Python的元组赋值操作可以实现元组中两个元素的交换：

~~~

a = 1
b = 2
(a, b) = (b, a)

~~~

## 标识符

Python的标识符中除了一些Python的关键字不能使用外，Python中的build-in标识符集合中的名字也不能使用。

Python中合法的标识符包括：

1) 第一个字符必须是字母或下划线
2) 剩下的字符可以是字母和数字或下划线
3) 大小写敏感

## 关键字

Python的关键字不像其他语言一样稳定，它的集合会随着Python的成长会改变，可以通过函数 **iskeyword()**查看名字是否为Python的关键字，Python把关键字列表和**iskeyword()**函数都放在 *keyword* 模块中。

## 内建

除了关键字以外，Python还可以在任何一级代码使用内建的名字集合，这些名字可以由解释器设置或使用，虽然 *build-in* 不是关键字，但是应该把他们作为系统保留字，不能作为其他的用途。有些情况下需要覆盖这些保留字，但是Python不支持重载标识符，所以任何时刻只有一个名字绑定。

*build-in* 是 *\_\_builtins\_\_* 模块的成员，在程序开始或在交互解释器中给出 **>>>** 提示符前就被解释器自动载入，可以把他们看成适用在任何一级Python代码的全局变量。

## 专用下划线标识符

Python用下划线作为变量前缀和后缀指定特殊变量：

\_XXX	
:   不用 **from moudle import * ** 导入

\_\_XXX\_\_
:   系统定义名字

\_\_XXX	
:   类中的私有变量名

## Python中的编程风格

### 文档

Python提供了一个机制，可以通过 *\_\_doc\_\_* 特殊变量动态得获取文档字符串。
在模块，类声明，或函数声明中第一个没有赋值的字符串可以用属性 *obj.\_\_doc\_\_* 来进行访问，obj是一个模块，类或函数的名字。

## 模块结构和布局

Python中的*\_\_name\_\_* 指示模块应该如何被加载，由于主程序代码无论以模块的方式导入还是直接执行，都可以执行Python代码，为了区别导入的模块是被调用还是被直接执行，Python通过 *\_\_name\_\_* 系统变量指定：

* 如果模块是被导入的， *\_\_name\_\_* 的值为模块名字
* 如果模块是被直接执行的， *\_\_name\_\_* 的值为 *\_\_main\_\_*

模块是对象，并且所有的模块都有一个内置属性 *\_\_name\_\_* 。一个模块的 *\_\_name\_\_*  的值取决于您如何应用模块。如果 *import* 一个模块，那么模块 *\_\_name\_\_*  的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这种情况下, *\_\_name\_\_* 的值将是一个特别缺省 *\_\_main\_\_* 。

## 内存管理

### 动态类型

Python中不但变量名不用事先声明，而且也不用对变量进行类型声明。Python语言中，对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python仍然是一种解释型语言。在创建的时候，解释器会根据语法和右侧的操作数来决定新对象类型。在对象创建后，一个该对象的引用会被赋值给左侧的变量。

### 内存分配

Python解释器承担了内存管理任务。

### 引用计数

Python为了保持追踪内存中的对象，使用了引用计数。
一个内部跟踪变量，称为一个引用计数器每一个对象的引用个数成为引用计数。当对象被创建的时候，就创建一个引用计数，当这个对象不再需要时，即给对象的引用计数为0时，就会被垃圾回收程序回收。

#### 增加引用计数

* 当对象被创建并将其引用赋值给变量的时候，该对象的引用计数设置为1
* 当同一个对象的引用被赋值给被的变量的时候，或者作为参数传递给别的函数的时候(相当于赋值)，或者成为容器对象的一个元素的时候，引用计数增加。

#### 减少引用计数

* 当一个局部引用离开其作用范围的时候，如函数执行结束时其内部的局部变量存储的对象的引用计数会减少
* 当存储对象引用的变量被del显式销毁时，引用计数会减少。
* 当存储对象引用的变量被赋值给其他的对象的引用的时候，对原对象的引用计数会减少。
* 当存储对象容器被销毁的时候，其元素的引用计数会减少。

#### del语句

del语句删除对象的一个引用

~~~

del obj1[, obj2[, obj3.....]]

~~~

del语句执行后会产生两个结果：

* 从现有的名字空间中删除变量名
* 对象的引用计数减1

注意：任何跟踪或调试程序会给一个对象增加一个额外的引用，这将会推迟该对象被回收。


## 垃圾收集

Python中不再被使用的内存会被一种称为垃圾收集机制释放。虽然解释器跟踪对象的引用计数，但是垃圾收集器负责释放内存。垃圾收集器是一块独立代码，它用来寻找引用计数为0的对象，同时它也会负责检查哪些引用计数不为0,但也应该被销毁的对象。

在一些特殊情况下可能会产生循环引用，一个循环引用发生在当有至少两个对象互相互相引用时，也就是说当所有别的引用都消失时，这些引用都仍然存在的情况，这种情况下不能只靠引用计数解决。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器，当一个对象的引用计数为0的时候，解释器会暂停，然后释放掉这个对象和仅有这个对象可访问的其他对象。垃圾收集器也会注意分配的总量很大的对象。在这种情况下，解释器会暂停下来，试图清理所有循环引用。

## Python中的一些有用的工具

Python有一些工具模块可以在开发过程中提供帮助

**pdb**
:   调试模块pdb允许设置断点，代码逐行执行，检查堆栈。还支持事后调试。

**logging**
:   logging模块是在Python2.3中新增加的，它定义了一些函数和类帮助程序实现灵活的日志系统。日志系统一共有五级：紧急，错误，警告，信息和调试。

**profile，hosthot，cProfile**
:   Python拥有几个不同的性能测试模块：
    profile
    :				profile最早的profile性能测试模块，是由Python编写的，用来测试函数的执行时间，以及每次脚本执行的总时间，既没有特定函数的执行时间，也没有被包含的子函数的调用时间。这个性能测试模块是3个性能测试模块中最古老，也是最慢的。
    hotshot
    :   hotshot模块是Python2.2中新增加的，它的目标是替代profile模块，它修复了profile模块的一些错误，该模块是由C语言写的，所以它有效的提高了性能。虽然hotshot解决了性能测试过载问题，但需要更多的时间来生成结果。
    cProfile
    :   cProfile模块是Python2.5新增加的，他用来替换掉已经称为历史的hotshot和profile模块。该性能测试模块存在的缺点是需要花较多的时间从日志文件中载入分析结果，不支持子函数状态细节以及某些测试结果不准确。这个性能测试模块也是由C语言实现的。
