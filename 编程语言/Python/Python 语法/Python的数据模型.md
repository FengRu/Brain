# 0x00 数据模型(Data model) {#data_model}

## 0x10 对象、值和类型(Objects, values and types)

在Python中，对象(Objects)是对数据的抽象。所有的数据在Python中都是通过对象或者对象间的关系来表示的。

Python中所有的对象都一个一个身份(identity)，一个类型(type)和一个值(value)。一个对象的身份在对象创建以后就不能被改变，可以认为一个对象的身份就是这个对象在内存中的地址值。Python的**is**操作符用于比较两个对象的身份是否是一样的。内建函数**id()**返回一个整数表示的对象的身份。

**CPython 实现细节：** 对于CPython，**id(x)**的值就是x存储的地址。

一个对象的类型决定了这个对象支持的操作，同时也决定了这个对象可能的值。内建函数**type()**返回一个对象的类型。和对象的身份一样，对象的类型也是不可以修改的。

一些对象的值可以被修改。对象的值可以被修改的对象被称为可变对象(mutable)；对象的值在对象被创建以后不能被改变的，被称为不可变对象(immutable)。(一个不可变容器中包含了一个可变对象的引用，则这个可变对象可以被修改，但是这个容器还是被认为是不可变的，因为这个容器中包含的对象是不能被改变的。所以，不可变类型在并不是说它只能包含不可变的值。)一个对象的可变性取决于它的类型：数字，字符串和元组是不可变的，而字典和列表是可变的。

对象不能被显式销毁。然而，当一些对象不被引用的时候，它们可能会被垃圾回收机制回收。一些实现允许延迟垃圾回收或者完全的忽略。这些都是垃圾回收机制的实现问题，只要保证那些能被引用的对象不被垃圾回收机制回收。

**CPython 实现细节：** CPython 当前采用引用计数的方式和定时(delayed)检测循环链接的垃圾(可选的)，当一个对象不被引用的时候，就会很快被垃圾回收机制回收，但是不保证会回收掉循环引用的对象。当一个对象不被引用的时候，不能依赖它会立即终结的假设。(所以，我们需要在文件访问完后立即调用close()函数)。

注意，在使用跟踪或者调试工具的时候，可能会保持引用那些本来会被垃圾回收掉的对象，使得这些对象仍旧存活。并且，在**try ... except**语句可能会导致那些本来会被回收掉的对象仍旧存活。

一些对象包含了对外部资源的引用，不如打开的文件或窗口。这些被引用的资源，在对象被垃圾回收以后被自动释放，但是，垃圾回收机制并不能保证一定会回收这些对象，所以，为了保证这些外部资源可以被释放掉，这些对象提供了一些显式的方式释放这些外部资源，通过使用**close()**方法来显式释放资源。通过 **try ... finally**字句和**with**语句提供了方便的方式来保证资源的释放。

一些对象包含了对其他对象的引用，这些对象被称为容器(containers)。比如元组，字典和列表就是容器。容器中的值是对象的引用，在大多数情况下，提到容器的值，我们一般指的是容器中的引用指向值，而不是这个值的引用(身份)。然而，当我们讨论容器的可变性的时候，我们讨论容器的值，指的是容器中的对象的引用。所以，对于一个元组，它是不可变类型的，但是如果一个元组中包含了一个列表，那么这个列表的值是可以修改的，但是这个列表的引用(身份)是一直不变的，那么，无论这个列表中的值怎么变化，对于包含这个列表的元组来说，它的包含的值(也就是这个列表的身份)是不会改变的，所以我们说元组的不可变类型。

类型几乎影响了对象的所有行为。即使是对象的身份，在一些情况下，也收到类型的影响。对于不可变类型，操作返回的新的值可能会引用同一个已经存在具有相同类型和值的对象，但是，对于可变类型，这是不可能的。比如：**a = 1; b = 1**，则a 和 b可能引用了同一个对象，这个依赖于实现。但是对于**c = []; d = []**，c和d保证是不会引用同一个对象的。

## 0x20 标准类型体系(The standard type hierachy)

以下部分是Python的内建类型。扩展模块(采用C，Java或其他语言编写的模块，依赖于特定的实现)可以定义额外的类型。Python可能在未来添加其他的类型到当前的类型体系中。

### 0x21 None

None类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建名字**None**来访问。这个对象用于缺失值的情况下。当一个函数没有显式指定返回值的时候，则这个函数将返回None。这个对象的真值是false。

### 0x22 NotImplemented

NotImplemented类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建的名字**NotImplemented**访问。数值方法和比较方法在对应的操作数没有对应的操作的时候应该返回这个对象。这个对象的真值是true。

### 0x23 Ellipsis

这个类型的对象只有一个值。并且只有一个对象拥有这个值。这个对象可以通过一个省略号**...**来访问，或者通过内建对象**Ellipsis**来访问。这个对象的真值是true。

### 0x24 numbers.Number

这个类型的对象是通过数值字面值来创建，并且作为数值操作或数值内建函数的返回值返回。数值对象是不可变的。一旦创建了数值对象，那么这个对象的值就不能被改变了。Python的数值基本和数学上的数值是一致的，但是对于数值的表示收到计算机的限制。

Python提供了整数(integers)，浮点数(floating)，和复数(complex numbers)。

#### 0x241 numbers.Integral

这个类型是对数学上整数的表示（正数和负数）。

这里有两种类型的整数：

整数(int)
:   整数类型表示了一个没有限定范围的数值，可以表示的长度受限于计算机的内存大小。整数支持移位和掩码操作等位操作。

布尔类型(bool)
:   这个类型表示True和False。布尔类型是整数类型的子集，布尔类型的值True和False相当于整数的0和1。并且，在大多数上下文中，如果需要将布尔值转换为字符串的时候，会对应装换为"True"和"False"。

#### 0x242 numbers.Real(float)

这个类型表示了机器级别的双精度浮点数。Python不支持单精度浮点数，Python为了简化语言，并不对单精度进行支持。

#### 0x243 numbers.Complex(complex)

这个类型表示复数，复数是两个双精度浮点数的组成的浮点数对。复数的实部和虚部可以通过复数对象z的z.real和z.imag获得。

### 0x25 序列(sequence)

序列用于表示有限的有序集合，通过非负的整数进行索引。内建函数**len()**用于返回序列中包含的对象的个数。序列的索引是从0开始的。可以通过下标操作符来获得指定索引的对象。

序列支持分片操作：**a[i:j]**表示选择序列中下标为k的对象，其中k满足i <= k < j。

一些序列支持额外的分片操作，可以指定步进长度，如**a[i:j:k]**，这用于选择所有下标为x = i + n * k，其中x满足 i <= x < j。

序列依据是不是可变的，可以分成如下几类：

#### 0x251 不可变序列(Immutable sequences)

不可变序列表示，当一个序列被创建以后，就不能被修改了。（但是序列中包含的对象是可以是可变的）。

* 字符串(Strings)	
一个字符串是一个包含了Unicode码的序列。字符串中所有的Unicode码值在U+0000 - U+10FFFF之间。Python不支持char类型；但是可以用一个字符长度的字符串代表char类型。内建函数**ord()**用于将一个字符串转换为对应的Unicode码值。内建函数**chr()**用于将一个范围在0-10FFFF之间的Unicode码值转换为对应的字符串。str类型的内建函数**str.encode()**通过给定的编码方式将一个str类型的对象转换为byte类型对象。而**str.decode()**用于做相反的操作。

* 元组(Tuples)	    
Python中的元组可以包含任何对象。一个以上的对象组成的元组通过逗号分隔。只有一个对象的元组，可以通过在对象后面添加逗号来表示只有一个对象的元组。（用一个括号包裹一个对象，并不会创建一个单个对象的元组，因为括号被用来对表达式进行分组，而不是创建元组）。一个空的元组可以用一个空的括号来表示。

* 字节序列(Bytes)	
一个字节序列对象是一个不可变的数组。字节序列中的对象是一个8位的字节，代表整数0-255。字节序列字面值(b'abc')和内建函数**bytes()**可以被用于构建字节序列对象。字节序列对象可以通过**decode()**方法解码成字符串。

#### 0x252 可变序列(Mutable sequences)

可变序列在创建以后可以被修改。下标操作符和分片符号可以被赋值，并且可以被del语句操作。

* 列表(List)	    
列表中的对象可以是任何Python对象。列表的形式是通过一个方括号将一系列通过逗号分隔的对象包裹起来。

* 字节数组(Byte Arrays)	    
一个直接数组对象是一个可变对象。可以通过内建函数**bytearray()**来创建字节数组对象。除了字节数组是可变的对象以外，所有的操作接口都是和不可变的字节序列一样的。

额外的**array**模块和**collections**模块提供了第三方的可变序列的实现。

### 0x26 集合类型(Set types)

集合类型用于表示无序的，有限的序列，其中序列中的对象是唯一的。集合对象不支持下标操作，但是集合对象可以被迭代。内建函数**len()**返回集合中对象的数目。集合的主要用处是进行快速的成员关系测试，从一个序列中删除重复的对象，并且在数学上支持集合运算。

对于集合中的对象，具有和字典的键值一样的不可变性规则。注意，对于数值类型的对象，遵循数值对象的比较规则：如果两个数值比较的结果是相等的，那么表示这两个对象是相等的（比如1和1.0），只有其中任何一个对象可以包含在集合中。

* Sets	    
Sets类型表示一个可变的集合类型。可以通过内建函数set()来创建。可以通过诸如add()等成员方法进行修改。

* Frozen sets	    
Frozen sets用于表示不可变集合。可以通过内建函数frozenset()来创建。一个frozenset对象是不可变的，并且是可哈希的。它可以作为其他集合中的对象，也可以作为字典的键值。

## 0x27 映射类型(Mappings)

映射类型用于表示有限的集合，集合中的对象可以被任意的索引集合索引。下标操作a[k]表示从映射类型对象a中通过索引k取出对应的对象。a[k]可以用于作为赋值操作的左值，也可以被del语句作用。内建函数**len()**返回映射对象中包含的对象的数目。

* Dictionaries      
字典用于表示有限的集合，集合中的元素差不多可以被任何值索引。只有那些包含了列表或者字典或者其他可变类型对象的值不能作为字典的键值外，其他类型都可以作为字典的键值。这是为了高效的计算字典的键值，需要键值的哈希值是一个常数。数值类型作为字典的键值，遵循一般的数值类型对比规则：如果两个数值比较的结果相等，那么这两个键值将在字典中索引相同的对象。

字典类型是可变的，可以通过使用**{...}**方式创建字典。

扩展模块 dbm.ndbm和dbm.gnu以及collections提供了额外的映射类型的实现。

## 0x28 可调用类型(Callable types)

可调用对象可以通过函数操作符进行调用。

### 0x281 用户自定义函数

用户自定义函数对象通过一个函数定义被创建。在函数被调用的时候，需要有和定义时的参数列表数目一样的参数被传递进去。

函数对象的特殊属性：

| 属性 | 描述 |W/R  |
|:----:|:-----|:---:|
| __doc__ | 函数对象的文档字符串，如果没有定义，则为None，不能被子类继承 | Writable |
| __name__ | 函数名 | Writable |
| __qualname__ | 函数的qualified 名字 | Writable |
| __module__ | 函数所在的模块的名字，如果没有，则为None | Writable |
| __defaults__ | 一个包含了默认参数值的元组，如果没有默认参数，则为None | Writable |
| __code__ | 函数对象编译以后的代码对象 | Writable |
| __globals__ | 一个字典的引用，字典中包含了函数的全局变量——全局名字空间是函数所在的模块的名字空间 | Readonly |
| __dict__ | 函数对象的名字空间 | Writable |
| __closure__ | 函数的自由变量组成的元组，如果没有自由变量，则为None | Writable |
| __annotations__ | 一个包含了属性注解的字典，键值是参数名，对于return注解，键值为'return'|Writable|
| __kwdefaults__ | 一个包含了默认的关键字属性的字典 | Writable |


函数对象也支持设置和获取任意的属性，通用的属性操作符(.)可以用于设置或获取这些属性。注意，Python当前的是实现只支持用户自定义函数的属性。内建函数的属性可能会在未来被支持。

### 0x282 实例方法

实例方法的只读属性包括：

* **\_\_self\_\_** 是类的实例对象
* **\_\_func\_\_** 是函数对象
* **\_\_doc\_\_** 是方法的文档字符串(值和**\_\_func\_\_.\_\_doc\_\_**一样)
* **\_\_name\_\_**是方法的名字(值和**\_\_func\_\_.\_\_name\_\_**一样)
* **\_\_module\_\_**是方法所在的模块的名字，如果没有则为None。

方法可以访问它当前对应的函数对象的任何属性。

在获得一个类的属性的时候（可能是通过类的实例对象来获取），如果这个类属性是一个用户自定义函数对象或者是一个类方法对象，则会创建一个用户自定义方法。

当通过类的实例对象来调用这个类中定义的用户自定义函数，则会创建一个实例方法，实例方法的**\_\_self\_\_**属性的值就是这个实例对象，这个时候，这个方法对象就被认为是绑定了的，这个方法对象的**\_\_func\_\_**属性的值就是原来那个用户自定义函数对象。

当通过类或实例的其他方法对象来创建用户自定义方法对象，则新的方法对象的**\_\_func\_\_**属性是原来那个方法对象的**\_\_func\_\_**属性。

当通过类或实例的类方法对象来创建实例方法对象，方法对象的**\_\_self\_\_**属性的值是这个类对象，而**\_\_func\_\_**属性是类对象对应的函数对象。

当一个实例方法对象被调用的时候，这个方法对象的**\_\_func\_\_**属性中的函数对象被调用，把存储在**\_\_self\_\_**属性中的这个类实例对象作为第一个参数被传递到这个函数对象中。例如：如果类对象C有一个函数对象f()，x是类C的实例对象，则当调用x.f(1)的时候，相当于是调用了C.f(x, 1)。

当一个实例方法对象是继承自一个类方法对象，则类实例被存储在这个方法对象的**\_\_self\_\_**属性中，所以x.f(1)和C.f(1)相当于是f(C,1)。

注意：从函数对象到实例方法对象的转换是发生在每次调用这个实例的方法的时候，在一些情况下，通过将实例对象的方法属性赋值被一个局部变量，可以在以后需要调用这个方法的时候直接调用这个局部变量，这可以起到优化程序的作用。这种类型的转换只是发生在获得用户自定义函数对象上，其他对象在获得的时候是不会进行转换的。注意：类实例对象的用户自定义函数对象并不会被绑定为方法对象，只有定义在类中的函数对象才会在调用的时候被转为绑定方法。

### 0x283 生成器函数

一个函数或者方法中使用了**yield**语句，则这个函数或方法被称为生成器函数。生成器函数在被调用的时候，会返回一个可以执行函数体的迭代器，调用迭代器的**iterator.\_\_next\_\_()**方法将会使函数体知晓直到通过yield语句产生一个结果。当函数执行了return语句，或者到达了最后，则抛出一个**StopIteration**异常，表明迭代器已经到达了最后。

### 0x284 内建函数

内建函数是对C实现的函数的封装，内建函数的参数类型和数目取决于C实现的函数。内建函数的只读属性包括：

* **\_\_doc\_\_**是函数的文档字符串，如果没有，则为None
* **\_\_name\_\_**是函数的名字
* **\_\_self\_\_**的值为None
* **\_\_module\_\_**是函数所在模块的名字，如果没有，则为None。

### 0x285 内建方法

内建方法是对内建函数伪装(disguise)，传递到C实现的对象作为一个隐式的额外参数被传递进去。比如内建方法alist.append()，其中的alist就是一个列表对象。内建方法的只读属性**\_\_self\_\_**的值是传递进去的对象。

### 0x286 类对象

类对象是可调用的，类对象的行为类似于创建实例的工厂，可以通过重载类的**\_\_new\_\_()**方法来修改对象的创建过程。调用类的时候，会将参数传递到**\_\_new\_\_()**方法中，一般情况下，会进一步调用**\_\_init\_\_()**方法来初始化新的实例对象。

### 0x287 类实例

实例对象可以通过重载**\_\_call\_\_()**方法来实现函数调用功能。

##  0x29 模块

模块是Python中代码的基本组织单元，模块通过import机制被创建，通过**import**语句或者调用类似于**importlib.import_module()**方法和内建的**\_\_import()\_\_()**方法。一个模块对象有一个通过字典创建的名字空间（定义在模块中的函数对象的**\_\_globals\_\_**属性引用的就是这个字典对象）。引用模块属性的时候会查看这个字典，如：m.x就相当于m.\_\_dict\_\_["x"]。模块对象没有包含初始化这个模块的代码对象（因为一旦模块被初始化以后，这些对象就没有用了）。

对模块的属性赋值会更新名字空间字典\_\_dict\_\_，如：m.x = 1 相当于是m.\_\_dict\_\_["x"] = 1。

模块的特殊只读属性包括：**\_\_dict\_\_**是通过字典类型创建的模块名字空间。

**CPython 实现细节：**由于CPython对模块字典的特殊的清除方式，当模块离开作用域的时候，即使模块的名字空间字典**\_\_dict\_\_**仍旧被别的对象引用，也会被清除。所以为了避免这种情况，在直接访问这个字典对象的时候，需要将字典对象拷贝一份或者保证这个字典对象在使用的时候是在外围作用域中。

模块对象中已经定义的属性包括：

* \_\_name\_\_属性是模块的名字
* \_\_doc\_\_属性是模块的文档字符串，如果不存在，则为None
* \_\_file\_\_如果模块是从文件中加载的，则这个属性是被加载的模块所在文件的路径，对于那些主要类型的模块，比如通过静态链接到解释器的C模块，这些模块的\_\_file\_\_属性可能会丢失。从动态链接库中加载的扩展模块，这些模块的\_\_file\_\_属性是动态链接库的路径。

## 0x2A 自定义类类型

自定义的类类型是通过类定义创建的。一个类有一个通过字典实现的名字空间。对类属性的引用会通过查看这个字典对象来获得。比如：C.x会转换为C.\_\_dict\_\_["x"]（存在一些其他的钩子来实现不同的属性查找方式）。如果属性的名字没有找到，则会在当前类的父类中继续查找。对于父类的查找顺序遵循C3-MRO（method resolution order），C3-MRO是一种即使是在具有多条来自公共的祖先的继承路径的继承结构中，也可以正确的工作。关于C3-MRO的详细信息，可以查看python的2.3版本中的[mro相关文档](https://www.python.org/download/releases/2.3/mro/)

当一个类的属性引用会产生一个类方法对象的时候，这个属性会被转化为一个实例方法对象，这个实例方法对象的**\_\_self\_\_**属性的值是这个类的类对象（比如类C）。当这个属性的引用会产生一个静态方法对象的时候，这个属性的引用会被转化为一个通过一个静态方法对象包裹的对象。Python的[描述符](https://docs.python.org/3/reference/datamodel.html#descriptors)提供了另外一种区别于通过类的名字空间字典对象\_\_dict\_\_来获取属性行为的方式。

对类属性进行赋值会更新类的名字空间字典对象，但不会更新父类的名字空间字典。

通过调用一个类对象会产生这个类的实例对象。

类对象的特殊属性：

* **\_\_name\_\_**是类的名字
* **\_\_module\_\_**是类所在的模块的名字
* **\_\_dict\_\_**是类的名字空间字典
* **\_\_bases\_\_**是包含了当前类的所有父类的元组，如果没有父类，则可以为空，
  元组中的顺序是这些父类在基类列表中出现的顺序
* **\_\_doc\_\_**是类的文档字符串，如果没有定义，则为None

## 0x2B 类实例

一个类实例是通过调用类对象获得的。一个类实例有一个通过字典对象**\_\_dict\_\_**实现的名字空间。实例对象的属性访问遵循如下的步骤：

* 首先，会对字典对象**\_\_dict\_\_**进行检查，查看访问的属性是否在这个字典对象中
* 如果在字典对象中没有找到这个属性，则会对这个实例对象的类对象进行搜索
    * 如果这个类属性是一个用户自定义函数对象，则这个函数对象会被转换为一个实例方法对象，这个实例方法对象的\_\_self\_\_属性是的值这个实例对象。
    * 如果属性是静态方法对象或类方法对象，也会被转化为实例的方法对象
* 如果在类属性中也没有找到，如果这个对象的类由一个\_\_getattr\_\_()方法，则会调用这个方法。

实例对象的属性的赋值和删除都会对实例对象的字典进行更新，而不会对这个实例所属的类对象的名字空间进行修改。如果类实现了\_\_setattr\_\_()或\_\_delattr()\_\_方法，则会通过这两个方法间接得对实例的名字空间字典对象进行更新。

实例对象的特殊属性：

* **\_\_dict\_\_**是实例的名字空间字典
* **\_\_class\_\_**是实例所属的类对象

## 0x2C I/O对象(文件对象)

一个文件对象表示一个打开的文件。可以有很多方式打开一个文件对象，内建函数**open()**可以用于创建一个文件对象，其他的包括**os.open()**，**os.fdopen()**，**makefile()**等都可以创建文件对象。

sys.stdin，sys.stdout，sys.stderr这三个对象用于初始化对应于解释器的标准输入，标准输出，和标准出错的文件对象。这三个对象都是通过文本模式实现的，并且这三个对象都实现了相同的接口**io.TextIOBase**抽象类

## 0x2D 内部类型

Python有一些内部类型用于解释器向用户暴露一些接口。

### 0x2D1 代码对象

代码对象用于表示已经被编译过的可执行Python字节码。代码对象和函数对象的区别是，函数对象包含了一个显式的指向全局作用域(这个函数被定义的模块的名字空间)的引用，而代码对象并没有包含上下文，并且在函数对象中包含了默认参数的值，而代码对象中并没有包含这些默认参数。和函数对象不同，代码对象是不可变的，并且不包含任何指向（直接或间接）可变对象的引用。

代码对象的只读属性包括：

* co_name表示函数的名字
* co_argcount表示位置参数的数目，包括包含了默认参数值的位置参数
* co_nlocals表示函数的局部变量的数目，局部变量包括函数的参数
* co_varnames表示局部变量的名字组成的元组，函数的参数出现在前面
* co_cellvars表示被内嵌函数引用的局部变量的名字组成的元组
* co_freevars表示函数的自由变量的名字组成的元组
* co_code表示字符串形式的字节码指令
* co_consts表示字节码需要使用的字面值
* co_names表示字节码需要使用的名字组成的列表
* co_filename表示编译出这个字节码的源文件的文件名
* co_firstlineno表示函数的第一行的行号
* co_lnotab表示通过字符串编码的从字节码偏移量到行号的映射（具体实现细节依赖于解释器）
* co_stacksize表示需要的栈大小，这个栈大小包括局部变量
* co_flags是一个整数，对解释器的一系列标记进行编码

对于co_flags属性，有以下一些值：

* 0x02 表示当这个函数是一个生成器的时候，设置这个值
* 0x04 表示当采用*arguments方式的参数的时候，会设置这个值
* 0x08 表示当采用\*\*keywords方式的参数的时候，会设置这个值

对于Future特性声明中(from \_\_future\_\_ import division)，co_flags属性用于表明代码对象是否在编译的时候包含了特殊的特性：

* 0x2000 表示函数在编译的时候包含了在future中的division特性
* 0x10和0x1000 表示使用的是早期版本的Python

其他的co_flags的值被保护用于内部使用。

如果一个代码对象表示的是一个函数，则co_consts属性的值的第一项是这个函数的文档字符串，如果这个函数没有文档字符串，则这一项的值为None。

### 0x2D2 帧对象(Frame objects)

帧(Frame)对象代表了正在执行的栈帧。帧对象一般出现在跟踪(traceback)对象中。

帧对象的只读属性包括：

* f_back表示前一个栈帧对象，即当前栈帧的调用者，如果当前栈帧是在栈低，则这个属性的值为None
* f_code表示当前正在栈帧中执行的代码对象
* f_locals表示当前局部变量的名字空间字典
* f_globals表示当前全局变量的名字空间字典
* f_builtins表示内建名字
* f_lasti给出了最后执行的指令（这是一个对代码对象的字节码字符串的索引）

帧对象的可写属性包括：

* f_trace，如果值为None，则表示这个栈帧是在最开始的时候创建的（用于debugger）
* f_lineno，栈帧中的当前的行号，通过在跟踪函数中改写这个属性的值可以跳转到给定的行（只对当前栈帧下面的栈帧有用）。通过改写这个属性，一个调试器可以用于实现跳转命令。

帧对象支持一个clear方法

frame.**clear()**
:   这个方法清理栈帧中所有指向局部变量的引用。如果栈帧是属于一个生成器的，则这个生成器会被终止。这可以帮助清理当前栈帧对象的引用循环（比如：当捕捉到一个异常，并把这个traceback存储起来的时候）。当前栈帧如果正在执行，则调用这个方法会抛出**RuntimeError**异常。

### 0x2D3 Traceback对象

Traceback对象表示对一个异常的栈跟踪。当出现一个异常的时候，会创建一个trackback对象。当搜索一个异常处理器的时候，会展开当前正在执行的栈帧，在每一个已经展开的层次上会在当前traceback前插入一个traceback对象。当进入了一个异常处理器，栈跟踪对当前程序就变成可用了。这个栈跟踪可以通过sys.exc_info()返回的元组中的第三个值来获得。当一个程序不包含合适的异常处理器的时候，这个栈跟踪会以合理的格式被输出到标准错误输出中。如果解释器是交互的，也可以通过sys.last_traceback获得。

特殊的只读属性：

* tb_next 表示栈跟踪的下一层（朝着异常产生的栈帧），如果当前没有下一层，则值为None。
* tb_frame 指向一个当前层次上正在执行的栈帧
* tb_lineno 异常产生时所在的行号
* tb_lasti 指出最后执行的指令的索引

在traceback中，如果在try语句中没有匹配的异常处理器或者finally语句，行号和最后执行的指令的索引可能会不一样。

### 0x2D4 分片对象(Slice objects)

分片对象用于为\_\_getitem\_\_()方法表示分片。内建函数**slice()**也会创建分片对象。

分片对象的特殊属性：

* start 表示分片的下边界，如果没有则为None
* stop 表示分片的上边界，如果没有则为None
* step 表示步进值，如果没有则为None

这些属性可以包含任何类型。

分片对象支持一个**indices**方法：

slice.**indices**(self, length)
:   这个方法接收一个整数的length参数，计算分片对象相关的信息。这个方法返回一个包含3个整数的元组，分别对应了分片的开始下标，结束下标和步进值。指数丢失或者越界都会以普通的分片方式处理。

### 0x2D5 静态方法对象

静态方法对象提供了一种打破将一个函数对象转换为一个方法对象的方式。一个静态方法对象是一个可以包裹任何对象的包装器，一般会作用于一个用户自定义方法对象。当通过类或者类实例来访问一个静态方法对象，会返回一个经过包裹过的对象，而不会进行其他的转换。静态方法对象不能递归调用，即使被包裹的对象可以被递归调用。静态方法对象可以通过内建的**staticmethod()**函数来创建。

### 0x2D6 类方法对象

类方法对象和静态方法对象类似，类方法对象也是一个包装器。类方法对象用于修改通过类或类实例来访问对象的方式。类方法对象可以通过内建函数**classmethod()**创建。
