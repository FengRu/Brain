# 0x00 数据模型(Data model) {#data_model}

## 0x10 对象、值和类型(Objects, values and types)

在Python中，对象(Objects)是对数据的抽象。所有的数据在Python中都是通过对象或者对象间的关系来表示的。

Python中所有的对象都一个一个身份(identity)，一个类型(type)和一个值(value)。一个对象的身份在对象创建以后就不能被改变，可以认为一个对象的身份就是这个对象在内存中的地址值。Python的**is**操作符用于比较两个对象的身份是否是一样的。内建函数**id()**返回一个整数表示的对象的身份。

**CPython 实现细节：** 对于CPython，**id(x)**的值就是x存储的地址。

一个对象的类型决定了这个对象支持的操作，同时也决定了这个对象可能的值。内建函数**type()**返回一个对象的类型。和对象的身份一样，对象的类型也是不可以修改的。

一些对象的值可以被修改。对象的值可以被修改的对象被称为可变对象(mutable)；对象的值在对象被创建以后不能被改变的，被称为不可变对象(immutable)。(一个不可变容器中包含了一个可变对象的引用，则这个可变对象可以被修改，但是这个容器还是被认为是不可变的，因为这个容器中包含的对象是不能被改变的。所以，不可变类型在并不是说它只能包含不可变的值。)一个对象的可变性取决于它的类型：数字，字符串和元组是不可变的，而字典和列表是可变的。

对象不能被显式销毁。然而，当一些对象不被引用的时候，它们可能会被垃圾回收机制回收。一些实现允许延迟垃圾回收或者完全的忽略。这些都是垃圾回收机制的实现问题，只要保证那些能被引用的对象不被垃圾回收机制回收。

**CPython 实现细节：** CPython 当前采用引用计数的方式和定时(delayed)检测循环链接的垃圾(可选的)，当一个对象不被引用的时候，就会很快被垃圾回收机制回收，但是不保证会回收掉循环引用的对象。当一个对象不被引用的时候，不能依赖它会立即终结的假设。(所以，我们需要在文件访问完后立即调用close()函数)。

注意，在使用跟踪或者调试工具的时候，可能会保持引用那些本来会被垃圾回收掉的对象，使得这些对象仍旧存活。并且，在**try ... except**语句可能会导致那些本来会被回收掉的对象仍旧存活。

一些对象包含了对外部资源的引用，不如打开的文件或窗口。这些被引用的资源，在对象被垃圾回收以后被自动释放，但是，垃圾回收机制并不能保证一定会回收这些对象，所以，为了保证这些外部资源可以被释放掉，这些对象提供了一些显式的方式释放这些外部资源，通过使用**close()**方法来显式释放资源。通过 **try ... finally**字句和**with**语句提供了方便的方式来保证资源的释放。

一些对象包含了对其他对象的引用，这些对象被称为容器(containers)。比如元组，字典和列表就是容器。容器中的值是对象的引用，在大多数情况下，提到容器的值，我们一般指的是容器中的引用指向值，而不是这个值的引用(身份)。然而，当我们讨论容器的可变性的时候，我们讨论容器的值，指的是容器中的对象的引用。所以，对于一个元组，它是不可变类型的，但是如果一个元组中包含了一个列表，那么这个列表的值是可以修改的，但是这个列表的引用(身份)是一直不变的，那么，无论这个列表中的值怎么变化，对于包含这个列表的元组来说，它的包含的值(也就是这个列表的身份)是不会改变的，所以我们说元组的不可变类型。

类型几乎影响了对象的所有行为。即使是对象的身份，在一些情况下，也收到类型的影响。对于不可变类型，操作返回的新的值可能会引用同一个已经存在具有相同类型和值的对象，但是，对于可变类型，这是不可能的。比如：**a = 1; b = 1**，则a 和 b可能引用了同一个对象，这个依赖于实现。但是对于**c = []; d = []**，c和d保证是不会引用同一个对象的。

## 0x20 标准类型体系(The standard type hierachy)

以下部分是Python的内建类型。扩展模块(采用C，Java或其他语言编写的模块，依赖于特定的实现)可以定义额外的类型。Python可能在未来添加其他的类型到当前的类型体系中。

### 0x21 None

None类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建名字**None**来访问。这个对象用于缺失值的情况下。当一个函数没有显式指定返回值的时候，则这个函数将返回None。这个对象的真值是false。

### 0x22 NotImplemented

NotImplemented类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建的名字**NotImplemented**访问。数值方法和比较方法在对应的操作数没有对应的操作的时候应该返回这个对象。这个对象的真值是true。

### 0x23 Ellipsis

这个类型的对象只有一个值。并且只有一个对象拥有这个值。这个对象可以通过一个省略号**...**来访问，或者通过内建对象**Ellipsis**来访问。这个对象的真值是true。

### 0x24 numbers.Number

这个类型的对象是通过数值字面值来创建，并且作为数值操作或数值内建函数的返回值返回。数值对象是不可变的。一旦创建了数值对象，那么这个对象的值就不能被改变了。Python的数值基本和数学上的数值是一致的，但是对于数值的表示收到计算机的限制。

Python提供了整数(integers)，浮点数(floating)，和复数(complex numbers)。

#### 0x241 numbers.Integral

这个类型是对数学上整数的表示（正数和负数）。

这里有两种类型的整数：

整数(int)
:   整数类型表示了一个没有限定范围的数值，可以表示的长度受限于计算机的内存大小。整数支持移位和掩码操作等位操作。

布尔类型(bool)
:   这个类型表示True和False。布尔类型是整数类型的子集，布尔类型的值True和False相当于整数的0和1。并且，在大多数上下文中，如果需要将布尔值转换为字符串的时候，会对应装换为"True"和"False"。

#### 0x242 numbers.Real(float)

这个类型表示了机器级别的双精度浮点数。Python不支持单精度浮点数，Python为了简化语言，并不对单精度进行支持。

#### 0x243 numbers.Complex(complex)

这个类型表示复数，复数是两个双精度浮点数的组成的浮点数对。复数的实部和虚部可以通过复数对象z的z.real和z.imag获得。

### 0x25 序列(sequence)

序列用于表示有限的有序集合，通过非负的整数进行索引。内建函数**len()**用于返回序列中包含的对象的个数。序列的索引是从0开始的。可以通过下标操作符来获得指定索引的对象。

序列支持分片操作：**a[i:j]**表示选择序列中下标为k的对象，其中k满足i <= k < j。

一些序列支持额外的分片操作，可以指定步进长度，如**a[i:j:k]**，这用于选择所有下标为x = i + n * k，其中x满足 i <= x < j。

序列依据是不是可变的，可以分成如下几类：

#### 0x251 不可变序列(Immutable sequences)

不可变序列表示，当一个序列被创建以后，就不能被修改了。（但是序列中包含的对象是可以是可变的）。

* 字符串(Strings)	
一个字符串是一个包含了Unicode码的序列。字符串中所有的Unicode码值在U+0000 - U+10FFFF之间。Python不支持char类型；但是可以用一个字符长度的字符串代表char类型。内建函数**ord()**用于将一个字符串转换为对应的Unicode码值。内建函数**chr()**用于将一个范围在0-10FFFF之间的Unicode码值转换为对应的字符串。str类型的内建函数**str.encode()**通过给定的编码方式将一个str类型的对象转换为byte类型对象。而**str.decode()**用于做相反的操作。

* 元组(Tuples)	    
Python中的元组可以包含任何对象。一个以上的对象组成的元组通过逗号分隔。只有一个对象的元组，可以通过在对象后面添加逗号来表示只有一个对象的元组。（用一个括号包裹一个对象，并不会创建一个单个对象的元组，因为括号被用来对表达式进行分组，而不是创建元组）。一个空的元组可以用一个空的括号来表示。

* 字节序列(Bytes)	
一个字节序列对象是一个不可变的数组。字节序列中的对象是一个8位的字节，代表整数0-255。字节序列字面值(b'abc')和内建函数**bytes()**可以被用于构建字节序列对象。字节序列对象可以通过**decode()**方法解码成字符串。

#### 0x252 可变序列(Mutable sequences)

可变序列在创建以后可以被修改。下标操作符和分片符号可以被赋值，并且可以被del语句操作。

* 列表(List)	    
列表中的对象可以是任何Python对象。列表的形式是通过一个方括号将一系列通过逗号分隔的对象包裹起来。

* 字节数组(Byte Arrays)	    
一个直接数组对象是一个可变对象。可以通过内建函数**bytearray()**来创建字节数组对象。除了字节数组是可变的对象以外，所有的操作接口都是和不可变的字节序列一样的。

额外的**array**模块和**collections**模块提供了第三方的可变序列的实现。

### 0x26 集合类型(Set types)

集合类型用于表示无序的，有限的序列，其中序列中的对象是唯一的。集合对象不支持下标操作，但是集合对象可以被迭代。内建函数**len()**返回集合中对象的数目。集合的主要用处是进行快速的成员关系测试，从一个序列中删除重复的对象，并且在数学上支持集合运算。

对于集合中的对象，具有和字典的键值一样的不可变性规则。注意，对于数值类型的对象，遵循数值对象的比较规则：如果两个数值比较的结果是相等的，那么表示这两个对象是相等的（比如1和1.0），只有其中任何一个对象可以包含在集合中。

* Sets	    
Sets类型表示一个可变的集合类型。可以通过内建函数set()来创建。可以通过诸如add()等成员方法进行修改。

* Frozen sets	    
Frozen sets用于表示不可变集合。可以通过内建函数frozenset()来创建。一个frozenset对象是不可变的，并且是可哈希的。它可以作为其他集合中的对象，也可以作为字典的键值。

