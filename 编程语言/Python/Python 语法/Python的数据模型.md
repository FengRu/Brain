# 0x00 数据模型(Data model) {#data_model}

## 0x10 对象、值和类型(Objects, values and types)

在Python中，对象(Objects)是对数据的抽象。所有的数据在Python中都是通过对象或者对象间的关系来表示的。

Python中所有的对象都一个一个身份(identity)，一个类型(type)和一个值(value)。一个对象的身份在对象创建以后就不能被改变，可以认为一个对象的身份就是这个对象在内存中的地址值。Python的**is**操作符用于比较两个对象的身份是否是一样的。内建函数**id()**返回一个整数表示的对象的身份。

**CPython 实现细节：** 对于CPython，**id(x)**的值就是x存储的地址。

一个对象的类型决定了这个对象支持的操作，同时也决定了这个对象可能的值。内建函数**type()**返回一个对象的类型。和对象的身份一样，对象的类型也是不可以修改的。

一些对象的值可以被修改。对象的值可以被修改的对象被称为可变对象(mutable)；对象的值在对象被创建以后不能被改变的，被称为不可变对象(immutable)。(一个不可变容器中包含了一个可变对象的引用，则这个可变对象可以被修改，但是这个容器还是被认为是不可变的，因为这个容器中包含的对象是不能被改变的。所以，不可变类型在并不是说它只能包含不可变的值。)一个对象的可变性取决于它的类型：数字，字符串和元组是不可变的，而字典和列表是可变的。

对象不能被显式销毁。然而，当一些对象不被引用的时候，它们可能会被垃圾回收机制回收。一些实现允许延迟垃圾回收或者完全的忽略。这些都是垃圾回收机制的实现问题，只要保证那些能被引用的对象不被垃圾回收机制回收。

**CPython 实现细节：** CPython 当前采用引用计数的方式和定时(delayed)检测循环链接的垃圾(可选的)，当一个对象不被引用的时候，就会很快被垃圾回收机制回收，但是不保证会回收掉循环引用的对象。当一个对象不被引用的时候，不能依赖它会立即终结的假设。(所以，我们需要在文件访问完后立即调用close()函数)。

注意，在使用跟踪或者调试工具的时候，可能会保持引用那些本来会被垃圾回收掉的对象，使得这些对象仍旧存活。并且，在**try ... except**语句可能会导致那些本来会被回收掉的对象仍旧存活。

一些对象包含了对外部资源的引用，不如打开的文件或窗口。这些被引用的资源，在对象被垃圾回收以后被自动释放，但是，垃圾回收机制并不能保证一定会回收这些对象，所以，为了保证这些外部资源可以被释放掉，这些对象提供了一些显式的方式释放这些外部资源，通过使用**close()**方法来显式释放资源。通过 **try ... finally**字句和**with**语句提供了方便的方式来保证资源的释放。

一些对象包含了对其他对象的引用，这些对象被称为容器(containers)。比如元组，字典和列表就是容器。容器中的值是对象的引用，在大多数情况下，提到容器的值，我们一般指的是容器中的引用指向值，而不是这个值的引用(身份)。然而，当我们讨论容器的可变性的时候，我们讨论容器的值，指的是容器中的对象的引用。所以，对于一个元组，它是不可变类型的，但是如果一个元组中包含了一个列表，那么这个列表的值是可以修改的，但是这个列表的引用(身份)是一直不变的，那么，无论这个列表中的值怎么变化，对于包含这个列表的元组来说，它的包含的值(也就是这个列表的身份)是不会改变的，所以我们说元组的不可变类型。

类型几乎影响了对象的所有行为。即使是对象的身份，在一些情况下，也收到类型的影响。对于不可变类型，操作返回的新的值可能会引用同一个已经存在具有相同类型和值的对象，但是，对于可变类型，这是不可能的。比如：**a = 1; b = 1**，则a 和 b可能引用了同一个对象，这个依赖于实现。但是对于**c = []; d = []**，c和d保证是不会引用同一个对象的。

## 0x20 标准类型体系(The standard type hierachy)

以下部分是Python的内建类型。扩展模块(采用C，Java或其他语言编写的模块，依赖于特定的实现)可以定义额外的类型。Python可能在未来添加其他的类型到当前的类型体系中。

### 0x21 None

None类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建名字**None**来访问。这个对象用于缺失值的情况下。当一个函数没有显式指定返回值的时候，则这个函数将返回None。这个对象的真值是false。

### 0x22 NotImplemented

NotImplemented类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建的名字**NotImplemented**访问。数值方法和比较方法在对应的操作数没有对应的操作的时候应该返回这个对象。这个对象的真值是true。

### 0x23 Ellipsis

这个类型的对象只有一个值。并且只有一个对象拥有这个值。这个对象可以通过一个省略号**...**来访问，或者通过内建对象**Ellipsis**来访问。这个对象的真值是true。

### 0x24 numbers.Number

这个类型的对象是通过数值字面值来创建，并且作为数值操作或数值内建函数的返回值返回。数值对象是不可变的。一旦创建了数值对象，那么这个对象的值就不能被改变了。Python的数值基本和数学上的数值是一致的，但是对于数值的表示收到计算机的限制。

Python提供了整数(integers)，浮点数(floating)，和复数(complex numbers)。

#### 0x241 numbers.Integral

这个类型是对数学上整数的表示（正数和负数）。

这里有两种类型的整数：

整数(int)
:   整数类型表示了一个没有限定范围的数值，可以表示的长度受限于计算机的内存大小。整数支持移位和掩码操作等位操作。

布尔类型(bool)
:   这个类型表示True和False。布尔类型是整数类型的子集，布尔类型的值True和False相当于整数的0和1。并且，在大多数上下文中，如果需要将布尔值转换为字符串的时候，会对应装换为"True"和"False"。

#### 0x242 numbers.Real(float)

这个类型表示了机器级别的双精度浮点数。Python不支持单精度浮点数，Python为了简化语言，并不对单精度进行支持。

#### 0x243 numbers.Complex(complex)

这个类型表示复数，复数是两个双精度浮点数的组成的浮点数对。复数的实部和虚部可以通过复数对象z的z.real和z.imag获得。
