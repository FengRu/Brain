# 0x00 数据模型(Data model) {#data_model}

## 0x10 对象、值和类型(Objects, values and types)

在Python中，对象(Objects)是对数据的抽象。所有的数据在Python中都是通过对象或者对象间的关系来表示的。

Python中所有的对象都一个一个身份(identity)，一个类型(type)和一个值(value)。一个对象的身份在对象创建以后就不能被改变，可以认为一个对象的身份就是这个对象在内存中的地址值。Python的**is**操作符用于比较两个对象的身份是否是一样的。内建函数**id()**返回一个整数表示的对象的身份。

**CPython 实现细节：** 对于CPython，**id(x)**的值就是x存储的地址。

一个对象的类型决定了这个对象支持的操作，同时也决定了这个对象可能的值。内建函数**type()**返回一个对象的类型。和对象的身份一样，对象的类型也是不可以修改的。

一些对象的值可以被修改。对象的值可以被修改的对象被称为可变对象(mutable)；对象的值在对象被创建以后不能被改变的，被称为不可变对象(immutable)。(一个不可变容器中包含了一个可变对象的引用，则这个可变对象可以被修改，但是这个容器还是被认为是不可变的，因为这个容器中包含的对象是不能被改变的。所以，不可变类型在并不是说它只能包含不可变的值。)一个对象的可变性取决于它的类型：数字，字符串和元组是不可变的，而字典和列表是可变的。

对象不能被显式销毁。然而，当一些对象不被引用的时候，它们可能会被垃圾回收机制回收。一些实现允许延迟垃圾回收或者完全的忽略。这些都是垃圾回收机制的实现问题，只要保证那些能被引用的对象不被垃圾回收机制回收。

**CPython 实现细节：** CPython 当前采用引用计数的方式和定时(delayed)检测循环链接的垃圾(可选的)，当一个对象不被引用的时候，就会很快被垃圾回收机制回收，但是不保证会回收掉循环引用的对象。当一个对象不被引用的时候，不能依赖它会立即终结的假设。(所以，我们需要在文件访问完后立即调用close()函数)。

注意，在使用跟踪或者调试工具的时候，可能会保持引用那些本来会被垃圾回收掉的对象，使得这些对象仍旧存活。并且，在**try ... except**语句可能会导致那些本来会被回收掉的对象仍旧存活。

一些对象包含了对外部资源的引用，不如打开的文件或窗口。这些被引用的资源，在对象被垃圾回收以后被自动释放，但是，垃圾回收机制并不能保证一定会回收这些对象，所以，为了保证这些外部资源可以被释放掉，这些对象提供了一些显式的方式释放这些外部资源，通过使用**close()**方法来显式释放资源。通过 **try ... finally**字句和**with**语句提供了方便的方式来保证资源的释放。

一些对象包含了对其他对象的引用，这些对象被称为容器(containers)。比如元组，字典和列表就是容器。容器中的值是对象的引用，在大多数情况下，提到容器的值，我们一般指的是容器中的引用指向值，而不是这个值的引用(身份)。然而，当我们讨论容器的可变性的时候，我们讨论容器的值，指的是容器中的对象的引用。所以，对于一个元组，它是不可变类型的，但是如果一个元组中包含了一个列表，那么这个列表的值是可以修改的，但是这个列表的引用(身份)是一直不变的，那么，无论这个列表中的值怎么变化，对于包含这个列表的元组来说，它的包含的值(也就是这个列表的身份)是不会改变的，所以我们说元组的不可变类型。

类型几乎影响了对象的所有行为。即使是对象的身份，在一些情况下，也收到类型的影响。对于不可变类型，操作返回的新的值可能会引用同一个已经存在具有相同类型和值的对象，但是，对于可变类型，这是不可能的。比如：**a = 1; b = 1**，则a 和 b可能引用了同一个对象，这个依赖于实现。但是对于**c = []; d = []**，c和d保证是不会引用同一个对象的。
