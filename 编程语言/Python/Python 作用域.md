# Python 作用域规则 {#python_scope_rule}

## 名字空间 {#namespace}

一个名字空间(namespace)，就是一个从名字到对象的映射。Python目前通过字典数据结构来实现名字空间(可能会在以后更改实现方式)。

属性(Attributes)可以是只读的，或者是可写的，所以对属性赋值是可能。模块属性是可写的，可以通过这种方式对模块变量进行赋值：

~~~

moduleName.attr = value

~~~

可写的属性也可以通过 *del* 语句删除（对其引用数减1，引用数如果为0，则被垃圾回收机制回收）。

名字空间在不同的时刻被创建，并拥有不同的生命周期。
* 对于built-in的名字空间，在Python解释器被启动的时候创建，并且在解释器关闭前一直存在。（built-in名字空间中的名字实际上是存在于一个称为 *\_\_builtins\_\_* 的模块中。）
* 模块的全局名字空间在模块定义被读取的时候创建。一般情况下，模块的名字空间存活到解释器关闭。被解释器直接调用的Python语句，不管是从脚本中读取还是通过交互模式输入的，都被认为处于一个名为 *\_\_main\_\_* 的模块中，所以它们拥有自己的全局名字空间。
* 局部名字空间在函数被执行的时候创建，并且在函数执行结束以后或者抛出一个没有被捕捉的异常后被销毁。

## 作用域(Scope) {#scope}

作用域是一个可以直接访问特定名字空间的Python程序的文本区域。

虽然作用域是静态的，但是在使用的时候是动态的。在执行过程中，存在至少三个可以直接访问名字空间的作用域，嵌套在一起：

* 最内部(innermost)的作用域，这是最先被搜索的作用域，在这个作用域中可以访问局部名字空间
* 外围函数(enclosing function)作用域，外围函数作用域不是一个，如果当前位置到全局作用域之间有多层函数嵌套，则从最靠近内部的外围作用域开始向外部进行搜索。在这个作用域中可以访问每个函数对应的局部名字空间。
* 最后第二层(next-to-last)作用域，这个作用域可以访问全局名字空间。
* 最外层(outermost)作用域，最后搜索的作用域，可以访问built-in名字空间。

这里，由于Python引入了built-in名字空间，所以变量查找顺序由之前的LGB变成LEGB（L：Local，E：Enclosing，G：Global，B：Built-in）。

这里的最内部作用域和外围函数作用域都是可以直接访问局部名字空间的，只是仅仅可以访问所在函数对应的局部名字空间。而且最内部作用域和外围函数作用域是动态的，当Python语句从最内层出来到最靠近的外围函数作用域时，该外围函数作用域就编程了当前的最内层作用域。

如果定义了一个全局的名字，那么在可以访问该模块的全局名字空间的作用域中，可以直接对这个名字进行引用和赋值。否则，所有不在最内部作用域的名字都是只读的（所有企图对这个名字进行的赋值会导致在当前的局部作用域中创建一个同名的名字，并屏蔽外部作用域的名字）。（这个应该是名字空间中，来自外部名字空间中的名字在当前名字空间中存在同名的，会被屏蔽掉，而且这个名字空间是静态解析的，所以碰到动态创建的作用域，问题就会暴露出来）。

通常，局部作用域引用当前函数的局部名字空间，如果Python代码执行到所有函数外，那么当前的局部作用域可以访问的名字空间就是全局名字空间，也就是所在模块的名字空间。类定义会在当前定义的局部作用域中引入一个新的名字空间，这个名字空间也是一个局部名字空间。

作用域是通过Python代码执行所在的文本区域来确定的，一个函数的全局作用域可以访问的名字空间就是这个函数所在的模块的名字空间，无论这个函数在哪里被调用。所以，在进行名字查找的时候，是在执行期间动态查找的，但是，语言定义的解析是在“编译期”（解释阶段）进行的，所以局部变量的解析是静态进行的。这就会导致Python编程中的一个问题：

~~~ {.python}

i = 0
def f():
    i = 8
    print i
f()
print i

~~~

上面的代码会报错误 **UnboundLocalError: local variable 'i' referenced before assignment** ，这是由于Python的作用域规则导致的。因为代码是采用静态解析名字空间的，所以在函数f()中变量i屏蔽了全局名字空间中的变量i，但是在访问i的时候，局部作用域中的i并没有被赋值，所以报错了。

实际上，所有引入名字的操作都引入到局部作用域中，特别的， **import** 语句和函数定义会在当前的局部作用域中绑定模块或函数的名字。（因为如果Python代码执行在模块的最外层，那么当前的作用域是局部作用域，但是可以访问的名字空间确实全局名字空间，所以通过 **import** 引入的名字其实还是在全局名字空间中，但是作用域确实局部作用域。这就体现了作用域规则的动态的。由于只能在局部作用域中引入名字，所以我们不能在函数内部为全局名字空间引入名字，为了向全局名字空间引入名字，只能把把局部作用域切换到和全局作用域同样的层次，是的局部作用域可以访问全局名字空间，这样就可以引入名字了。

可以看出，在Python 2.x中，可以引入名字空间的只有三种情况：函数定义，模块定义和类定义。
