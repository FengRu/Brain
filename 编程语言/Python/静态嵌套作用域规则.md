# Python 的静态嵌套作用域 (Statically Nested Scopes) {#statically_nested_scopes}

## 介绍(introduction) {#introduction}
Python的静态嵌套作用域从Python 2.2引入，并且代码出现在Python 2.1中。

在Python的以前版本中（2.0之前,包括2.0），只有三种名字空间：local，global，built-in名字空间。额外引入的嵌套作用域允许在本地作用域中对外围函数中的名字进行解析引用。

这个特性的引入，导致lambda和其他函数嵌套可以引用定义在外围作用域中的变量。现在，lambda必须通过默认参数来显式创建绑定到lambda名字空间的名字。

Python 2.0定义了三种名字空间：local namespace，global namespace，builtin namespace。根据这个定义，如果函数A定义在函数B中，那么绑定在B中的名字在A里是不可见的。而引入嵌套作用域以后，在B中绑定的名字可以在A中引用。

嵌套作用域的引入主要针对两个问题：对于lambda表达式使用过程中的限制，以及新手对于和其他支持嵌套作用域的语言之间的疑惑。

lambda表达式生成一个执行一条语句的匿名函数，常用于回调函数。在Python 2.0中，为了使用lambda表达式，必须作为参数显式传递需要用到的名字到lambda表达式中。

~~~

from Tkinter import *
      root = Tk()
      Button(root, text="Click here",
             command=lambda root=root: root.test.configure(text="..."))

~~~

这种方式很笨重，特别是当需要传递很多参数的时候。而且在一些情况下，程序无法通过编译。

## 详细 (specification) {#specification}

Python是一个块结构的静态作用域语言，一个代码块是程序的基本单位，比如模块，类定义，函数体。

名字(Names)用于对对象的引用，名字通过绑定操作引入。名字绑定的操作包括：参数声明，赋值操作，类和函数定义，import语句，for语句以及except字句。名字绑定发生在块中，而类定义，函数定义或者模块定义都会定义块。

如果名字在代码块的任何位置，那么在则个代码块中引用这个名字将会使用这个代码块中的绑定的对象（这会导致在引用名字的时候，名字还没有被绑定）。

如果全局名字出现在代码块中，所有对这个名字的引用都会从顶层名字空间中搜索，名字在顶层名空间中搜索时，访问的是全局作用域，包括包含挡圈代码块的模块的名字空间和builtin名字空间，首先搜索当前模块的名字空间，如果没有找到，则所属builtin的名字空间。

如果名字带当前块中使用了，但是在当前代码块中没有绑定，，也没有在全局作用域中绑定这个名字，则认为这个名字绑定在最靠近的外围函数中，对这个最靠近的外围函数区域进行搜索（注意：如果最靠近的外围函数区域是类定义区域，则在类定义域中的名字对于当前作用域是不可见的）。

一个类定义是一个可能包含使用和定义名字操作的可执行语句，这些引用遵循正常的名字解析规则。定义的类的名字空间会成为这个类的一个字典属性。

下面的操作是名字绑定操作，如果这些操作出现在一个块中，则它们会在当前块中引入新的本地名字，除非已经有了一个全局声明：


* 函数定义
* 参数声明
* 类定义
* 赋值语句
* import导入语句
* 隐式赋值，通过for语句或者except字句

当Python在使用包含了自由变量（即在外围函数作用域中的变量）的嵌套作用域的时候，有一些情况是非法的：

* 如果在内部作用域中引用一个自由变量，则不能删除这个名字， *del name* 会导致一个 **SystemError** 异常。

* 如果在一个函数体内使用带有宽限定符的import语句时（**import * **），如果这个函数包含了一个包含自由变量的嵌套代码块，则编译器会抛出一个 **SystemError** 异常。

* 如果在一个函数体内使用 *exec* ，并且这个函数体内包含了拥有自由变量的嵌套代码块，则编译器会抛出一个 **SystemError** 异常，除非 *exec* 显式指定本地作用域（即：**exec obj** 是非法的，但是 **exec obj in ns** 是合法的）

* 如果一个在函数作用域中绑定的名字出现在模块的全局名字空间中或者builtin名字空间中，并且这个函数拥的内嵌函数引用了这个名字，则编译器会抛出一个警告，名字解析规则在Python 2.0和Python 2.2中会有不同的结果。
