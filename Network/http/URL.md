# 0x00 URL

## 0x10 URI和URL

URL是浏览器寻找信息时所需要的资源的位置。通过URL，人类和应用程序才能找到、分享和使用网络上的数据资源。

URI是一类更加通用的资源标识符，URL实际上是URI的一个子集。URI是一个通用的概念，由两个子集URL和URN构成。

![](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/180px-URI_Euler_Diagram_no_lone_URIs.svg.png)

URL是通过描述资源的位置来标识资源的。但是URN是通过名字来识别资源的，和资源所处的位置无关。

HTTP规范采用URI来作为资源标识符，但是实际上，HTTP应用程序处理的只是URI的一个子集URL。

对于一个URL  **http://www.google.com/resource-path** ,分为三部分：

* URL schema - 这里的schema就是http，schema用于告知web客户端怎么访问资源，在这里就是采用http协议来访问对应的资源。
* URL host - host(www.google.com)用于指定浏览器的位置，这部分告诉web客户端资源的位置。
* URL path - 资源路径path(resource-path)用于指定资源在对应服务器的哪个特定的资源。

## 0x20 URL的语法

URL提供了一种定位互联网上任何资源的方式，这些资源可以通过不同的schema来访问（如：HTTP、FTP、SMTP），所以URL的语法会随着schema的不同而有差异。

虽然不同的schema对应的URL语法不同，但是大部分URL都遵循通用的URL语法：

~~~

<schema>://<user>:<password>@<host>/<path>;<params>?<query>#<frag>

~~~

上面定义了通用的URL语法，但是几乎没有哪个URL包含上面提到的所有的组件。URL中最重要的3个部分是：schema、host和path。

通用URL组件

| 组件 | 描述 | 默认值 |
|:------:|:------|:---------:|
|schema|访问服务器以获取资源时采用哪种协议|无|
|user|某些schema在访问资源时需要用户名|匿名|
|password|user后面可以包含password，以冒号(:)分隔|<E-mail地址>|
|host|资源宿主服务器的主机名或者是点分IP地址|无|
|port|资源宿主服务器正在监听的端口号|每个schema特有|
|path|服务器上资源的本地名，由一个斜杠将前面的URL组件分隔开。路径组件的语法和采用的schema有关|无|
|params|一些schema需要参数组件，参数的格式是<name=value>组成的键值对。URL中可以包含多个参数字段，参数和其他组件之间，参数和参数之间采用分号(;)分隔|无|
|query|一些schema需要查询组件，查询组件的内容没有通用格式。使用字符"?"来和其他URL组件分隔|无|
|frag|片段组件用于表示一小片或一部分资源的名字。请求资源时，不会讲frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符"#"将其与其他URL组件分隔开|无|

### 0x21 Schema

Schema是规定如何访问指定资源的主要标识符，它会告诉负责解析URL的应用程序应该采用什么协议。HTTP 的url中采用的schema就是http。

Schema组件必须是一个字母开头，通过冒号(:)和其他组件分隔，并且是不区分大小写的。

### 0x22 Host & Port

为了在网络上找到资源，需要知道资源在哪个主机上，以及这个主机上的哪个端口上对这种资源提供了服务。URL的主机和端口组件提供了需要的信息。

主机（Host）组件提供了标识能够访问资源的宿主计算机。可以通过域名或者IP地址来表示主机。

端口（Port）组件标识了服务器正在监听的网络端口。对于HTTP协议来说，默认的端口为80。

### 0x23 User & Password

很多服务器需要提供用户名和密码进行验证以后才可以访问资源，比如常见的FTP服务器。

一些应用程序在使用URL的时候要求用户输入用户名和密码，比如FTP，如果用户没有提供，那么通常会提供一个默认的用户名和密码。对于一个FTP URL，如果没有指定用户名和密码，则默认会插入匿名用户（anonymous）作为用户名，并发送一个默认的密码（不同的客户端会采用不同的默认密码）。

用户名和密码在URL中通过@符号和其他URL组件进行分隔，而用户名和密码之间采用冒号（:）进行分隔。

### 0x24 Path

URL的路径组件说明了资源在服务器中的位置，路径通常类似于一个分级的文件系统路径。

路径组件中通过斜杠（/）来将路径分成多个路径段，每个路径段都可以有自己的**参数**组件。

### 0x25 Param

对于一些Schema，除了包含主机名和指定资源具体位置的路径以外，还包含了参数组件，负责解析URL的应用程序需要这些参数来访问资源。

为了向应用程序提供它们需要的参数，URL中的参数组件可以为其提供参数。URL中的参数组件是一个名/值对列表，通过分号（;）和其他URL组件以及名/值对之间分隔开。

URL的路径组件可以通过斜杠（/）将路径组件分隔成若干个路径段，每个路径段都可以有自己的参数：

~~~

http://url-host/path-part1;param1=value1/path-part2;param2=value2

~~~

### 0x26 Query

很多资源，比如数据库服务，都可以通过查询来请求特定的资源。

URL中的查询组件通过"?"和其他组件进行分隔。URL的查询组件和标识网关资源的URL路径组件一起被发送给网关资源。

查询组件的格式没有特别的要求，一般网关都需要一系列格式为"名/值"对的查询参数，名值对之间通过符号"&"分隔。

~~~

http://url-host/path?query1&query2

~~~

### 0x27 Frag

有些资源，如HTML，除了资源级别外，还可以进行进一步的划分。

为了引用部分资源或资源的一个片段，URL支持使用片段组件来表示一个资源内部的片段。片段通过符号"#"来将片段组件和其他URL组件之间进行分隔。

## 0x30 相对URL

URL有两种方式：**绝对URL**和**相对URL**。绝对URL中包含了访问资源需要的完整信息。

相对URL是一种不完整的URL，要从相对URL中获取访问资源所需要的全部信息，就需要相对于一个基础URL来进行解析。

相对URL是对URL的一种缩写记法。使用相对URL，编写HTML时，可以省略URL中的Schema，host以及其他一些URL组件。这些省略的组件可以从基础URL中获得。其他Schema对应的URL也可以用相对URL。

### 0x31 基础URL

解析相对URL的时候，首先需要找到基础URL。基础URL是作为相对URL的参考点使用的。基础URL可以通过以下方式找到：

* 在资源中显式提供
  
   有些资源会显式指定基础URL。比如在HTML中可以包含一个定义了基础URL的<BASE>标记
   
* 封装资源的基础URL
  
  如果在一个没有显式指定基础的URL的资源中发现了一个相对URL，则将它所属的资源的URL作为基础URL
  
### 0x32 解析相对URL

为了通过相对URL来访问资源，需要将相对URL通过基础URL解析为绝对URL。

解析相对URL的算法：

~~~

已经解析了的相对URL
if (schema为空):
    继承基础URL中的schema，检查host、port、user、password组件:
    if (所有组件为空):
        继承基础URL中的host、port、user、password组件，检查路径组件
        if (没有前导"/"的非空路径):
		    从正在处理的路径中删除"./"和"<seg>/./"
        else if (路径为空):
		    继承基础URL路径，检查参数组件
				 if (参数为空):
				    继承基础URL参数，检查查询组件
						if (查询为空):
						    继承基础URL的查询组件
        else if (带有前导"/"的非空路径):
		    处理绝对路径
    将继承的组件和相对组件组合成新的绝对URL
else if (所有组件为空):
    默认为基础URL
else if (非空的schema):
    是绝对URL

~~~

## 0x40 URL字符集

URL是可移植的。它要统一地命名互联网上所有的资源，这也意味着需要通过不同的协议来传送这些资源。不同的协议在传输资源的时候会使用不同的机制，所以，URL需要可以通过任意协议安全地被传输。

安全地传输URL意味着在传输过程中不能有数据丢失。有些协议，如简单邮件传输协议(STMP)，使用的传输方法会剥去一些特殊的字符。为了避免出现这些问题，URL只能使用一些相对较小的、通用的安全字母表中的字符。

为了使得URL是可读的，在URL中不能包含不可见和不可打印的字符。同时，为了保证URL的完整性，URL在设计的时候需要兼顾字母表之外的二进制数据，所以需要一种转义机制，能够将不安全的字符编码成安全地字符。通过转义序列，可以通过ASCII字符集的有限子集对任何字符或数据进行编码，实现了URL的可移植性和完整性。

### 0x41 编码机制

为了避开安全字符集的表示范围的限制，人们设计了一种编码机制，用于在URL中表示不安全的字符。通过转义方式将不安全的字符编码到URL中。这种转义方式包含一个百分号(%)，后面跟两个表示ASCII码的十六进制数。

| 字符 | ASCII码 | 示例 |
|:------:|:----------|:-------|
| ~ | 126(0x7E) | http://google.com/%7Eexp.html |
| backspace | 32(0x20) | http://google.com/%20exp.html |
| % | 37(0x25) | http://google.com/%25exp.html |

### 0x42 字符限制

在URL中，有几个字符被保留下来，作为特殊的字符。有些字符不在定义的US-ASCII可打印字符集中。还有一些字符可能会与互联网上的网关和协议产生混淆，所以不赞成使用。

下表列出了一些字符，在将这些字符作为保留用途之外使用的时候，在URL中使用需要对其进行编码。

| 字符 | 保留/受限 |
|:-----:|:--------------|
| % | 保留作为编码字符时的转义标志 |
| / | 保留作为路径中分隔路径段的定界符 |
| . | 保留作为路径组件中使用 |
| .. | 保留作为路径组件中使用 |
| # | 保留作为分段定界符使用 |
| ? | 保留作为查询字符串定界符使用 |
| ; | 保留作为参数定界符使用 |
| : | 保留作为schema，user/password，以及host/port组件的定界符使用 |
| $+ | 保留 |
| @&= | 在一些schema的上下文中有特殊的含义，保留 |
| {}|\^~[]` | 由于一些Agent代理和网关的不安全处理，使用受限 |
| <>" | 不安全，这些字符在URL范围外通常是有意义的，所以需要对其进行编码 |
| 0x00-0x1F、0x7F | 受限， 这些字符在ASCII中表示不可打印字符 |
| 大于0x7F | 受限，这些十六进制超过了ASCII字符的可表示范围 |


## 0x50 常见Schema对应的URL格式

| Schema | 描述 |
|:------:|:-------|
| http | http://< host>:< port>/< path>?< query>#< frag> |
| https | https://< host>:< port>/< path>?< query>#< frag>|
|ftp | ftp://< user>:< password>@< host>:< port>/< path>;< param> |
|file | file://< host>/< path> |
|telnet | telnet://< user>:< password>@< host>:< port>/|
